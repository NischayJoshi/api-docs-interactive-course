// Auto-generated from course.json
// DO NOT EDIT THIS FILE DIRECTLY - Edit course.json instead

const courseData = {
  "courseTitle": "Complete API Documentation Mastery Course",
  "description": "Transform from absolute beginner to professional API documentation writer. Master REST APIs, HTTP, OpenAPI, authentication, and real-world documentation practices through comprehensive hands-on learning.",
  "estimatedHours": 15,
  "modules": [
    {
      "id": "module-api-basics",
      "title": "API Basics & HTTP Fundamentals",
      "description": "Learn what APIs are, how HTTP powers them, and why documentation matters.",
      "icon": "üß≠",
      "lessons": [
        {
          "id": "lesson-what-is-api",
          "slug": "what-is-api",
          "title": "Understanding APIs: The Restaurant Analogy",
          "estimated_time_minutes": 26,
          "learning_objectives": [
            "Explain what an API is using real-world analogies",
            "Understand the client-server model",
            "Recognize why API documentation is critical",
            "Identify the role of a documentation writer"
          ],
          "prerequisites": [],
          "contentHtml": "<h3>What Is an API?</h3><p>Welcome! Before we write a single word of documentation, we need to deeply understand what we're documenting.</p><p>The most common analogy for an <strong>API (Application Programming Interface)</strong> is a <em>waiter at a restaurant</em>:</p><ul><li><strong>You (the client)</strong> are a customer sitting at a table</li><li><strong>The kitchen (the server)</strong> has all the food (the data)</li><li><strong>The API is the waiter</strong> who takes your request and brings back the response</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Think of API documentation as the <em>menu</em>. Without a menu, customers don't know what to order. A bad menu causes confusion; a great menu ensures a smooth experience.</div><h3>The Client-Server Model</h3><p>An API enables communication in a <strong>client-server model</strong>:</p><pre><code>Client  ‚îÄ‚îÄrequest‚îÄ‚îÄ>  Server\n        <‚îÄ‚îÄresponse‚îÄ‚îÄ</code></pre><ul><li><strong>Client:</strong> The application requesting data (mobile app, website, script)</li><li><strong>Server:</strong> The system that processes requests and returns data</li><li><strong>API:</strong> The interface that defines how they communicate</li></ul><h3>Why API Documentation Matters</h3><p>API documentation is the bridge between the server's capabilities and the developer's understanding. Poor docs lead to:</p><ul><li>‚ùå Developer frustration</li><li>‚ùå Support tickets flooding your team</li><li>‚ùå Slow adoption of your API</li><li>‚ùå Integration errors</li></ul><p>Great documentation leads to:</p><ul><li>‚úÖ Fast developer onboarding</li><li>‚úÖ Reduced support burden</li><li>‚úÖ Higher API adoption</li><li>‚úÖ Happy developers = successful product</li></ul><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't assume developers will \"figure it out.\" If it's not documented, it doesn't exist.</div><h3>Your Role as a Documentation Writer</h3><p>You are not just passively listing features‚Äîyou are actively <em>guiding developers to successful outcomes</em>. Think of yourself as:</p><ul><li>A teacher (educating about the API)</li><li>A guide (showing the best path forward)</li><li>A translator (converting technical specs into clear instructions)</li></ul><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>APIs enable client-server communication</li><li>Documentation is the \"menu\" that guides developers</li><li>Good docs = happy developers = successful API</li><li>Your job: guide, teach, and translate</li></ul></div>",
          "examples": [
            {
              "title": "Real API Request - GET Example",
              "language": "bash",
              "code": "# Client sends a request to the server\ncurl -X GET 'https://api.videodb.io/v1/videos/abc123' \\\n  -H 'Authorization: Bearer YOUR_API_KEY'"
            },
            {
              "title": "Server Response - JSON",
              "language": "json",
              "code": "{\n  \"id\": \"abc123\",\n  \"title\": \"My First Video\",\n  \"duration\": 120,\n  \"status\": \"ready\"\n}"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "In the restaurant analogy, what does the API represent?",
              "choices": [
                "The customer",
                "The waiter",
                "The kitchen",
                "The menu"
              ],
              "answerIndex": 1,
              "explanation": "The API is like the waiter‚Äîit takes requests from the client (customer) and returns responses from the server (kitchen)."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "What is the primary role of API documentation?",
              "choices": [
                "To replace code comments",
                "To guide developers in using the API successfully",
                "To list all internal server functions",
                "To provide legal disclaimers"
              ],
              "answerIndex": 1,
              "explanation": "API documentation guides developers to successful outcomes by clearly explaining how to use the API."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'Understanding APIs: The Restaurant Analogy', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'Understanding APIs: The Restaurant Analogy', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'Understanding APIs: The Restaurant Analogy', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "What is an API? (MDN Web Docs)",
              "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction"
            },
            {
              "type": "youtube",
              "title": "APIs for Beginners",
              "url": "https://www.youtube.com/watch?v=GZvSYJDk-us"
            }
          ]
        },
        {
          "id": "lesson-http-methods",
          "slug": "http-methods",
          "title": "HTTP Methods: The Verbs of the Web",
          "estimated_time_minutes": 32,
          "learning_objectives": [
            "Master the 5 core HTTP methods (GET, POST, PUT, PATCH, DELETE)",
            "Identify idempotent vs. non-idempotent operations",
            "Understand safe vs. unsafe methods",
            "Document HTTP methods correctly in API docs"
          ],
          "prerequisites": [
            "lesson-what-is-api"
          ],
          "contentHtml": "<h3>HTTP Methods: The Core Verbs</h3><p>HTTP methods (also called <em>verbs</em>) define the type of action to perform on a resource. Think of them as the commands you give to the server.</p><h3>The 5 Essential HTTP Methods</h3><h4>1. GET ‚Äî Retrieve Data</h4><p><strong>Purpose:</strong> Request data from the server without modifying anything.</p><ul><li>‚úÖ Safe: Does not change server state</li><li>‚úÖ Idempotent: Multiple identical requests have the same effect</li><li>üìñ <strong>Documentation Example:</strong> \"Retrieves a list of all videos in the collection\"</li></ul><h4>2. POST ‚Äî Create New Resources</h4><p><strong>Purpose:</strong> Submit data to create a new resource.</p><ul><li>‚ùå Not safe: Changes server state</li><li>‚ùå Not idempotent: Each request creates a new resource</li><li>üìñ <strong>Documentation Example:</strong> \"Creates a new video upload\"</li></ul><h4>3. PUT ‚Äî Replace/Update Resources</h4><p><strong>Purpose:</strong> Replace an entire resource with new data.</p><ul><li>‚ùå Not safe: Changes server state</li><li>‚úÖ Idempotent: Sending the same PUT request multiple times has the same result</li><li>üìñ <strong>Documentation Example:</strong> \"Updates the entire video metadata\"</li></ul><h4>4. PATCH ‚Äî Partial Updates</h4><p><strong>Purpose:</strong> Update only specific fields of a resource.</p><ul><li>‚ùå Not safe: Changes server state</li><li>‚úÖ Often idempotent (depends on implementation)</li><li>üìñ <strong>Documentation Example:</strong> \"Updates the video title and description\"</li></ul><h4>5. DELETE ‚Äî Remove Resources</h4><p><strong>Purpose:</strong> Delete a resource from the server.</p><ul><li>‚ùå Not safe: Changes server state</li><li>‚úÖ Idempotent: Deleting the same resource multiple times has the same effect</li><li>üìñ <strong>Documentation Example:</strong> \"Permanently deletes a video\"</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Always document which HTTP method to use for each endpoint. Developers need to know whether they're creating (POST) or updating (PUT/PATCH).</div><h3>Idempotency: Why It Matters</h3><p>An <strong>idempotent</strong> operation produces the same result no matter how many times you perform it.</p><table style='width:100%; border-collapse: collapse; margin: 1rem 0;'><tr style='background: #f0f0f0;'><th style='padding: 0.5rem; border: 1px solid #ddd;'>Method</th><th style='padding: 0.5rem; border: 1px solid #ddd;'>Idempotent?</th><th style='padding: 0.5rem; border: 1px solid #ddd;'>Why?</th></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>GET</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Reading data doesn't change anything</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>POST</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Each request creates a new resource</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>PUT</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Replacing the same resource yields the same result</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>PATCH</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ö†Ô∏è Maybe</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Depends on how it's implemented</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>DELETE</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Deleting an already-deleted resource is still \"deleted\"</td></tr></table><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't use GET for operations that modify data (e.g., deleting a record). Use the correct HTTP method for semantic clarity.</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>GET = Read, POST = Create, PUT = Replace, PATCH = Update, DELETE = Remove</li><li>Idempotent methods: GET, PUT, DELETE (usually PATCH)</li><li>Always document the correct HTTP method for each endpoint</li></ul></div>",
          "examples": [
            {
              "title": "GET Request - Retrieve a Video",
              "language": "bash",
              "code": "curl -X GET 'https://api.videodb.io/v1/videos/abc123' \\\n  -H 'Authorization: Bearer YOUR_API_KEY'"
            },
            {
              "title": "POST Request - Create a New Video",
              "language": "python",
              "code": "import requests\n\nurl = 'https://api.videodb.io/v1/videos'\nheaders = {'Authorization': 'Bearer YOUR_API_KEY'}\ndata = {\n    'title': 'My New Video',\n    'url': 'https://example.com/video.mp4'\n}\n\nresponse = requests.post(url, json=data, headers=headers)\nprint(response.json())"
            },
            {
              "title": "PUT Request - Replace Video Metadata",
              "language": "javascript",
              "code": "fetch('https://api.videodb.io/v1/videos/abc123', {\n  method: 'PUT',\n  headers: {\n    'Authorization': 'Bearer YOUR_API_KEY',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    title: 'Updated Title',\n    description: 'Updated Description'\n  })\n})\n.then(res => res.json())\n.then(data => console.log(data));"
            },
            {
              "title": "PATCH Request - Partial Update",
              "language": "bash",
              "code": "curl -X PATCH 'https://api.videodb.io/v1/videos/abc123' \\\n  -H 'Authorization: Bearer YOUR_API_KEY' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"title\": \"New Title Only\"}'"
            },
            {
              "title": "DELETE Request - Remove a Video",
              "language": "bash",
              "code": "curl -X DELETE 'https://api.videodb.io/v1/videos/abc123' \\\n  -H 'Authorization: Bearer YOUR_API_KEY'"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which HTTP method is idempotent?",
              "choices": [
                "POST",
                "PUT",
                "Both",
                "Neither"
              ],
              "answerIndex": 1,
              "explanation": "PUT is idempotent because replacing the same resource multiple times yields the same result. POST creates a new resource each time, so it's not idempotent."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "You want to update only the title of a video. Which method is most appropriate?",
              "choices": [
                "GET",
                "POST",
                "PUT",
                "PATCH"
              ],
              "answerIndex": 3,
              "explanation": "PATCH is used for partial updates. PUT would require sending the entire resource data."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Methods: The Verbs of the Web', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Methods: The Verbs of the Web', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Methods: The Verbs of the Web', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Methods (MDN)",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods"
            },
            {
              "type": "article",
              "title": "REST API Tutorial - HTTP Methods",
              "url": "https://restfulapi.net/http-methods/"
            }
          ]
        },
        {
          "id": "lesson-status-codes",
          "slug": "http-status-codes",
          "title": "HTTP Status Codes: Understanding Server Responses",
          "estimated_time_minutes": 26,
          "learning_objectives": [
            "Categorize HTTP status codes by class (2xx, 3xx, 4xx, 5xx)",
            "Identify the most common status codes",
            "Document error responses effectively",
            "Write helpful error messages in API docs"
          ],
          "prerequisites": [
            "lesson-http-methods"
          ],
          "contentHtml": "<h3>HTTP Status Codes: The Server's Response Language</h3><p>Every HTTP response includes a <strong>status code</strong> that tells the client what happened. Understanding these codes is essential for writing clear error documentation.</p><h3>Status Code Classes</h3><h4>2xx ‚Äî Success ‚úÖ</h4><ul><li><strong>200 OK:</strong> Request succeeded, data returned</li><li><strong>201 Created:</strong> Resource successfully created (POST)</li><li><strong>204 No Content:</strong> Success, but no data to return (DELETE)</li></ul><h4>3xx ‚Äî Redirection ‚Ü©Ô∏è</h4><ul><li><strong>301 Moved Permanently:</strong> Resource has a new permanent URL</li><li><strong>302 Found:</strong> Temporary redirect</li><li><strong>304 Not Modified:</strong> Cached version is still valid</li></ul><h4>4xx ‚Äî Client Errors ‚ùå</h4><p>These indicate the client did something wrong.</p><ul><li><strong>400 Bad Request:</strong> Malformed request syntax</li><li><strong>401 Unauthorized:</strong> Missing or invalid authentication</li><li><strong>403 Forbidden:</strong> Authenticated but not authorized</li><li><strong>404 Not Found:</strong> Resource doesn't exist</li><li><strong>422 Unprocessable Entity:</strong> Valid syntax, but semantic errors (e.g., invalid field values)</li><li><strong>429 Too Many Requests:</strong> Rate limit exceeded</li></ul><h4>5xx ‚Äî Server Errors üî•</h4><p>These indicate the server failed to fulfill a valid request.</p><ul><li><strong>500 Internal Server Error:</strong> Generic server failure</li><li><strong>502 Bad Gateway:</strong> Invalid response from upstream server</li><li><strong>503 Service Unavailable:</strong> Server temporarily down</li><li><strong>504 Gateway Timeout:</strong> Upstream server didn't respond in time</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Always document the expected status codes for each endpoint, including both success and error scenarios.</div><h3>Documenting Error Responses</h3><p>When documenting errors, include:</p><ol><li><strong>Status Code:</strong> e.g., 404</li><li><strong>Error Message:</strong> Human-readable description</li><li><strong>Error Code:</strong> Machine-readable identifier (optional)</li><li><strong>Resolution Steps:</strong> How to fix the issue</li></ol><h4>Example Error Documentation</h4><pre><code>404 Not Found\n\nThe requested video was not found.\n\nResponse:\n{\n  \"error\": {\n    \"code\": \"VIDEO_NOT_FOUND\",\n    \"message\": \"No video exists with ID abc123\",\n    \"suggestion\": \"Verify the video ID and try again.\"\n  }\n}</code></pre><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't just say \"Error occurred.\" Provide actionable error messages that help developers debug issues.</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>2xx = Success, 3xx = Redirect, 4xx = Client error, 5xx = Server error</li><li>Always document expected status codes</li><li>Provide clear, actionable error messages</li></ul></div>",
          "examples": [
            {
              "title": "200 OK - Successful Response",
              "language": "json",
              "code": "{\n  \"id\": \"abc123\",\n  \"title\": \"My Video\",\n  \"status\": \"ready\"\n}"
            },
            {
              "title": "201 Created - Resource Created",
              "language": "json",
              "code": "{\n  \"id\": \"new456\",\n  \"title\": \"New Video\",\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}"
            },
            {
              "title": "400 Bad Request - Validation Error",
              "language": "json",
              "code": "{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid request parameters\",\n    \"details\": [\n      {\n        \"field\": \"title\",\n        \"issue\": \"Title is required\"\n      }\n    ]\n  }\n}"
            },
            {
              "title": "401 Unauthorized - Missing Auth",
              "language": "json",
              "code": "{\n  \"error\": {\n    \"code\": \"UNAUTHORIZED\",\n    \"message\": \"Missing or invalid API key\",\n    \"suggestion\": \"Include your API key in the Authorization header\"\n  }\n}"
            },
            {
              "title": "404 Not Found - Resource Missing",
              "language": "json",
              "code": "{\n  \"error\": {\n    \"code\": \"NOT_FOUND\",\n    \"message\": \"Video not found\",\n    \"resource_id\": \"abc123\"\n  }\n}"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which status code indicates a successful resource creation?",
              "choices": [
                "200 OK",
                "201 Created",
                "204 No Content",
                "301 Moved Permanently"
              ],
              "answerIndex": 1,
              "explanation": "201 Created is the standard status code for successful POST requests that create new resources."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "What's the difference between 401 and 403?",
              "choices": [
                "No difference, they're interchangeable",
                "401 = not authenticated, 403 = not authorized",
                "401 = server error, 403 = client error",
                "401 = temporary, 403 = permanent"
              ],
              "answerIndex": 1,
              "explanation": "401 Unauthorized means you haven't authenticated (missing/invalid credentials). 403 Forbidden means you're authenticated but don't have permission for this resource."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Status Codes: Understanding Server Responses', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Status Codes: Understanding Server Responses', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'HTTP Status Codes: Understanding Server Responses', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Status Codes (MDN)",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"
            },
            {
              "type": "website",
              "title": "HTTP Status Dogs (Fun Reference)",
              "url": "https://httpstatusdogs.com/"
            }
          ]
        },
        {
          "id": "lesson-rest-principles",
          "slug": "rest-principles",
          "title": "REST Architecture & Principles",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Understand the 6 REST architectural constraints",
            "Explain stateless communication and its benefits",
            "Design resource-based URLs following REST principles",
            "Apply REST best practices in API documentation"
          ],
          "prerequisites": [
            "lesson-what-is-api"
          ],
          "contentHtml": "\n<h2>REST Architecture & Principles</h2>\n\n<p>Welcome! Now that you understand what APIs are, let's dive deep into REST - the architectural style that powers most modern web APIs.</p>\n\n<div class='callout callout-info'>\n<strong>üìò What You'll Learn:</strong> By the end of this lesson, you'll understand REST principles deeply and know how to recognize and document RESTful APIs correctly.\n</div>\n\n<h3>What is REST?</h3>\n\n<p><strong>REST (Representational State Transfer)</strong> is an architectural style for designing networked applications. It was introduced by Roy Fielding in his 2000 PhD dissertation and has become the dominant approach for web APIs.</p>\n\n<p><strong>Key Point:</strong> REST is NOT a protocol like HTTP or SOAP. It's a set of architectural constraints and principles that, when followed, create scalable, maintainable, and intuitive APIs.</p>\n\n<h3>The 6 REST Constraints</h3>\n\n<p>A truly RESTful API must adhere to these six constraints:</p>\n\n<h4>1. Client-Server Separation</h4>\n<p>The client (user interface) and server (data storage/logic) are independent and can evolve separately.</p>\n\n<p><strong>Why it matters:</strong> You can update the mobile app without touching the server, or scale the backend without changing client code. This separation of concerns enables independent development and deployment.</p>\n\n<h4>2. Stateless Communication</h4>\n<p>Each request from client to server must contain ALL information needed to understand and process the request. The server doesn't store client session state between requests.</p>\n\n<p><strong>Example:</strong> Instead of the server remembering \"User logged in at 10am,\" each request includes an authentication token that proves identity.</p>\n\n<p><strong>Benefits:</strong></p>\n<ul>\n<li>Easy to scale horizontally (any server can handle any request)</li>\n<li>Improved reliability (no session state to lose if a server crashes)</li>\n<li>Simpler server implementation</li>\n<li>Better visibility for monitoring and debugging</li>\n</ul>\n\n<h4>3. Cacheable</h4>\n<p>Responses must explicitly indicate whether they can be cached. This improves performance by reducing server load and network latency.</p>\n\n<p><strong>Example:</strong> A GET request for user profile data might be cached for 5 minutes, while POST requests creating new data are never cached.</p>\n\n<h4>4. Uniform Interface</h4>\n<p>This is the fundamental constraint that makes REST simple and consistent. It includes:</p>\n\n<ul>\n<li><strong>Resource-based URLs:</strong> Use nouns (<code>/users/123</code>) not verbs (<code>/getUser?id=123</code>)</li>\n<li><strong>Standard HTTP methods:</strong> GET, POST, PUT, PATCH, DELETE for actions</li>\n<li><strong>Self-descriptive messages:</strong> Each message contains enough info to process it</li>\n<li><strong>Hypermedia (HATEOAS):</strong> Responses include links to related resources</li>\n</ul>\n\n<p><strong>Why it matters:</strong> Developers who understand one REST API can quickly learn others. Consistency drastically lowers the learning curve.</p>\n\n<h4>5. Layered System</h4>\n<p>The client can't tell if it's connected directly to the end server or through intermediaries like load balancers, proxies, or caches.</p>\n\n<p><strong>Why it matters:</strong> You can add security layers, caching layers, or load balancing without clients knowing or caring. This enables scaling and security improvements without API changes.</p>\n\n<h4>6. Code on Demand (Optional)</h4>\n<p>Servers can optionally send executable code (like JavaScript) to extend client functionality. This is the only optional constraint and is rarely used in REST APIs.</p>\n\n<h3>Resource-Based URLs: The Heart of REST</h3>\n\n<p>REST APIs organize everything around <strong>resources</strong> (nouns representing entities). Each resource has a unique URL.</p>\n\n<h4>‚úÖ RESTful URL Design</h4>\n<pre><code>GET    /users              # Get list of all users\nGET    /users/123          # Get specific user (ID 123)\nPOST   /users              # Create new user\nPUT    /users/123          # Replace entire user 123\nPATCH  /users/123          # Update specific fields of user 123\nDELETE /users/123          # Delete user 123\n\n# Nested resources (relationships)\nGET    /users/123/orders   # Get all orders for user 123\nPOST   /users/123/orders   # Create new order for user 123\nGET    /users/123/orders/456   # Get specific order\n</code></pre>\n\n<h4>‚ùå Non-RESTful Design (What NOT to do)</h4>\n<pre><code>GET /getAllUsers\nGET /getUserById?id=123\nPOST /createUser\nPOST /updateUser\nGET /deleteUser?id=123     # Wrong method for deletion!\nPOST /users/search         # Should be GET with query params\n</code></pre>\n\n<div class='callout callout-tip'>\n<strong>üí° Golden Rule:</strong> Use <strong>nouns for resources</strong> in URLs and <strong>HTTP methods for actions</strong>. The URL identifies WHAT (the resource), the HTTP method specifies HOW (the action).\n</div>\n\n<h3>Stateless vs. Stateful: Deep Dive</h3>\n\n<h4>Stateful Approach (‚ùå Not RESTful)</h4>\n<pre><code># Request 1: Login\nPOST /login\nBody: {username: \"alice\", password: \"secret\"}\nResponse: {session_id: \"abc123\"}\n\n# Server stores: Session abc123 = {user: \"alice\", logged_in: true}\n\n# Request 2: Get profile\nGET /profile\nHeaders: {Cookie: \"session_id=abc123\"}\n\n# Server looks up session abc123, finds user=\"alice\"\nResponse: {name: \"Alice\", email: \"alice@example.com\"}\n\nProblem:\n- Server must store session for every user\n- Doesn't scale well (new server doesn't know about session)\n- Session can be lost if server restarts\n- Hard to load balance across multiple servers\n</code></pre>\n\n<h4>Stateless Approach (‚úÖ RESTful)</h4>\n<pre><code># Request 1: Login\nPOST /auth/login\nBody: {username: \"alice\", password: \"secret\"}\nResponse: {token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"}\n\n# Server creates JWT token containing user info, doesn't store anything\n\n# Request 2: Get profile\nGET /users/me\nHeaders: {Authorization: \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"}\n\n# Server validates token signature (no database lookup!)\n# Token itself contains user ID and permissions\nResponse: {name: \"Alice\", email: \"alice@example.com\"}\n\nBenefits:\n- Server stores nothing (stateless)\n- Any server can handle any request\n- Easy to scale horizontally\n- No session management complexity\n- Token contains all needed info\n</code></pre>\n\n<h3>HTTP Methods & Idempotency</h3>\n\n<p>Understanding which methods are safe and idempotent is crucial for REST:</p>\n\n<table style='width:100%; border-collapse: collapse; margin: 1rem 0;'>\n<tr style='background: #f5f5f5;'>\n<th style='padding: 0.5rem; border: 1px solid #ddd;'>Method</th>\n<th style='padding: 0.5rem; border: 1px solid #ddd;'>Safe?</th>\n<th style='padding: 0.5rem; border: 1px solid #ddd;'>Idempotent?</th>\n<th style='padding: 0.5rem; border: 1px solid #ddd;'>Purpose</th>\n</tr>\n<tr>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'><strong>GET</strong></td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>Read/retrieve data</td>\n</tr>\n<tr>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'><strong>POST</strong></td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>Create new resource</td>\n</tr>\n<tr>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'><strong>PUT</strong></td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>Replace entire resource</td>\n</tr>\n<tr>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'><strong>PATCH</strong></td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Usually</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>Update specific fields</td>\n</tr>\n<tr>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'><strong>DELETE</strong></td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚ùå No</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>‚úÖ Yes</td>\n<td style='padding: 0.5rem; border: 1px solid #ddd;'>Remove resource</td>\n</tr>\n</table>\n\n<p><strong>Safe:</strong> Doesn't modify server state (read-only operations)</p>\n<p><strong>Idempotent:</strong> Making the same request multiple times has the same effect as making it once</p>\n\n<div class='callout callout-success'>\n<strong>‚úÖ Why Idempotency Matters:</strong> If a network error causes your DELETE request to be sent twice, idempotency guarantees the second delete is harmless (resource already deleted). This makes APIs robust and fault-tolerant.\n</div>\n\n<h3>Documenting REST APIs</h3>\n\n<p>As an API documentation writer, you need to clearly communicate REST principles:</p>\n\n<ul>\n<li><strong>Resource names:</strong> Document what each resource represents</li>\n<li><strong>URL patterns:</strong> Show the URL structure clearly</li>\n<li><strong>HTTP methods:</strong> List which methods work on each endpoint</li>\n<li><strong>Idempotency:</strong> Mention if operations are idempotent (helps developers handle retries)</li>\n<li><strong>Statefulness:</strong> Explain that APIs are stateless (each request needs auth)</li>\n<li><strong>Caching:</strong> Document which endpoints can be cached and for how long</li>\n</ul>\n\n<div class='callout callout-warning'>\n<strong>‚ö†Ô∏è Common Documentation Mistake:</strong> Don't just list endpoints. Explain the RESTful design - why resources are organized this way, how they relate, and how developers should think about using them.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>REST has 6 constraints (client-server, stateless, cacheable, uniform interface, layered, code-on-demand)</li>\n<li>Stateless = each request is self-contained with all needed info</li>\n<li>Resources use noun-based URLs, HTTP methods define actions</li>\n<li>Idempotent methods (GET, PUT, DELETE) can be safely retried</li>\n<li>REST principles make APIs intuitive, scalable, and maintainable</li>\n<li>Document the \"why\" behind RESTful design, not just the \"what\"</li>\n</ul>\n</div>\n\n<div class='callout callout-success'>\n<strong>üéØ Next Steps:</strong> Complete the quiz to solidify your REST knowledge, then move to the next lesson on JSON and data formats!\n</div>\n                ",
          "examples": [
            {
              "title": "RESTful Resource Hierarchy",
              "language": "http",
              "code": "# Collection and individual resources\nGET    /api/v1/users                   # Get list of users\nGET    /api/v1/users/123               # Get user 123\nPOST   /api/v1/users                   # Create new user\nPUT    /api/v1/users/123               # Replace user 123\nPATCH  /api/v1/users/123               # Update user 123\nDELETE /api/v1/users/123               # Delete user 123\n\n# Nested resources (relationships)\nGET    /api/v1/users/123/posts         # Get all posts by user 123\nPOST   /api/v1/users/123/posts         # Create post for user 123\nGET    /api/v1/users/123/posts/456     # Get specific post\nPUT    /api/v1/users/123/posts/456     # Update post 456\nDELETE /api/v1/users/123/posts/456     # Delete post 456\n\n# Query parameters for filtering/sorting\nGET    /api/v1/users?role=admin        # Get admin users\nGET    /api/v1/posts?sort=date&order=desc  # Get posts sorted by date\n"
            },
            {
              "title": "Stateless JWT Authentication",
              "language": "javascript",
              "code": "// Step 1: Login and get JWT token\nconst loginResponse = await fetch('https://api.example.com/auth/login', {\n  method: 'POST',\n  headers: {'Content-Type': 'application/json'},\n  body: JSON.stringify({\n    username: 'alice',\n    password: 'secret123'\n  })\n});\n\nconst {token} = await loginResponse.json();\n// token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n\n// Step 2: Use token in subsequent requests (stateless!)\nconst profileResponse = await fetch('https://api.example.com/users/me', {\n  method: 'GET',\n  headers: {\n    'Authorization': `Bearer ${token}`,  // ‚Üê Token contains all auth info\n    'Accept': 'application/json'\n  }\n});\n\n// Server doesn't need to look up session\n// Token itself contains: user ID, permissions, expiration\n// Any server can validate the token independently\n// This is stateless - each request is self-contained\n\nconst profile = await profileResponse.json();\nconsole.log(profile);\n"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What does 'stateless' mean in REST architecture?",
              "choices": [
                "The server never stores any data in databases",
                "Each request contains all information needed to process it",
                "The API doesn't have any state machines",
                "Clients cannot maintain any local state"
              ],
              "answerIndex": 1,
              "explanation": "Stateless means each request from client to server must contain ALL information needed to process it. The server doesn't store client session state between requests, making systems easier to scale and more reliable."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Which URL structure is RESTful?",
              "choices": [
                "GET /getUserByIdentifier?id=123",
                "POST /createNewUserAccount",
                "GET /users/123",
                "GET /deleteUser/123"
              ],
              "answerIndex": 2,
              "explanation": "GET /users/123 is RESTful because it uses a resource-based URL with a noun ('users') and the resource identifier, paired with the appropriate HTTP method (GET). RESTful URLs use nouns for resources, not verbs."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Which HTTP method is NOT idempotent?",
              "choices": [
                "GET",
                "PUT",
                "POST",
                "DELETE"
              ],
              "answerIndex": 2,
              "explanation": "POST is NOT idempotent - sending the same POST request twice typically creates two resources. GET, PUT, and DELETE are idempotent: calling them multiple times has the same effect as calling once."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "What is the main benefit of the 'uniform interface' REST constraint?",
              "choices": [
                "It makes APIs faster",
                "It reduces the number of endpoints needed",
                "It creates consistency, making APIs easier to learn",
                "It eliminates the need for documentation"
              ],
              "answerIndex": 2,
              "explanation": "Uniform interface creates consistency across REST APIs. When all APIs follow the same conventions (resource-based URLs, standard HTTP methods), developers who know one REST API can quickly understand others, dramatically lowering the learning curve."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "In REST, what should resource names in URLs be?",
              "choices": [
                "Verbs describing actions (e.g., /getUsers, /createOrder)",
                "Nouns describing entities (e.g., /users, /orders)",
                "Mixed verbs and nouns for clarity",
                "Database table names exactly"
              ],
              "answerIndex": 1,
              "explanation": "RESTful URLs use nouns for resources (/users, /orders, /products). The HTTP method (GET, POST, PUT, DELETE) specifies the action. This separation makes APIs intuitive: the URL identifies WHAT (resource), the method specifies HOW (action)."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "Roy Fielding's REST Dissertation (Original)",
              "url": "https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm"
            },
            {
              "type": "article",
              "title": "REST API Tutorial",
              "url": "https://restfulapi.net/"
            },
            {
              "type": "article",
              "title": "Understanding RESTful APIs",
              "url": "https://www.restapitutorial.com/"
            }
          ]
        }
      ]
    },
    {
      "id": "module-http-protocols",
      "title": "HTTP Protocol Deep Dive",
      "description": "Master HTTP methods, headers, status codes, and the request/response lifecycle",
      "icon": "üåê",
      "lessons": [
        {
          "id": "lesson-http-headers",
          "slug": "http-headers-explained",
          "title": "HTTP Headers Complete Guide",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Understand common HTTP request and response headers",
            "Use Content-Type and Accept headers correctly",
            "Implement custom headers for API features",
            "Document header requirements clearly"
          ],
          "prerequisites": [
            "lesson-what-is-api"
          ],
          "contentHtml": "<h2>HTTP Headers Complete Guide</h2>\n\n<p>Headers provide metadata about requests and responses. Let's master them.</p>\n\n<h3>What Are HTTP Headers?</h3>\n\n<p>Headers are key-value pairs sent with HTTP requests and responses:</p>\n\n<pre><code>GET /api/users HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer abc123\nContent-Type: application/json\nAccept: application/json</code></pre>\n\n<h3>Common Request Headers</h3>\n\n<h4>Authorization</h4>\n<p>Authenticates the request:</p>\n<pre><code>Authorization: Bearer YOUR_TOKEN\nAuthorization: Basic dXNlcjpwYXNz\nAuthorization: API-Key YOUR_KEY</code></pre>\n\n<h4>Content-Type</h4>\n<p>Specifies the format of the request body:</p>\n<pre><code>Content-Type: application/json        # JSON data\nContent-Type: application/xml         # XML data\nContent-Type: multipart/form-data     # File uploads\nContent-Type: application/x-www-form-urlencoded  # Form data</code></pre>\n\n<h4>Accept</h4>\n<p>Tells server what response formats client can handle:</p>\n<pre><code>Accept: application/json              # Prefer JSON\nAccept: application/xml               # Prefer XML\nAccept: application/json, application/xml  # Either is fine</code></pre>\n\n<h4>User-Agent</h4>\n<p>Identifies the client application:</p>\n<pre><code>User-Agent: MyApp/1.0 (iOS 15.0)</code></pre>\n\n<h3>Common Response Headers</h3>\n\n<h4>Content-Type</h4>\n<p>Tells client what format the response is in:</p>\n<pre><code>Content-Type: application/json; charset=utf-8</code></pre>\n\n<h4>Cache-Control</h4>\n<p>Defines caching behavior:</p>\n<pre><code>Cache-Control: public, max-age=3600\nCache-Control: no-store</code></pre>\n\n<h4>Location</h4>\n<p>Used with 201 Created to show new resource URL:</p>\n<pre><code>HTTP/1.1 201 Created\nLocation: /api/users/123</code></pre>\n\n<h4>Rate Limit Headers</h4>\n<pre><code>X-RateLimit-Limit: 100\nX-RateLimit-Remaining: 87\nX-RateLimit-Reset: 1640000000</code></pre>\n\n<h3>Custom Headers</h3>\n\n<p>APIs often use custom headers (prefix with <code>X-</code> traditionally):</p>\n<pre><code>X-Request-ID: abc-123-def-456\nX-API-Version: 2.0\nX-Response-Time: 45ms</code></pre>\n\n<div class='callout callout-tip'>\n<strong>üí° Documentation Tip:</strong> Create a \"Common Headers\" reference table showing all headers your API uses, required vs optional, and examples.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Headers provide metadata for requests and responses</li>\n<li>Authorization, Content-Type, Accept are most common</li>\n<li>Cache-Control and Location control behavior</li>\n<li>Document all custom headers your API uses</li>\n</ul>\n</div>\n",
          "examples": [
            {
              "title": "Complete Request with Headers",
              "language": "javascript",
              "code": "const response = await fetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {\n    'Authorization': 'Bearer YOUR_TOKEN',\n    'Content-Type': 'application/json',\n    'Accept': 'application/json',\n    'User-Agent': 'MyApp/1.0',\n    'X-Request-ID': 'unique-id-123'\n  },\n  body: JSON.stringify({\n    name: 'Alice',\n    email: 'alice@example.com'\n  })\n});\n\n// Check response headers\nconsole.log('Content-Type:', response.headers.get('Content-Type'));\nconsole.log('Rate Limit:', response.headers.get('X-RateLimit-Remaining'));"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which header tells the server what format you're sending in the request body?",
              "choices": [
                "Accept",
                "Content-Type",
                "Authorization",
                "User-Agent"
              ],
              "answerIndex": 1,
              "explanation": "Content-Type specifies the format of the request body (e.g., application/json). Accept specifies what formats you can receive in the response."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Headers Reference",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"
            }
          ]
        },
        {
          "id": "lesson-request-response-lifecycle",
          "slug": "request-response-lifecycle",
          "title": "HTTP Request/Response Lifecycle",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Understand the complete HTTP request/response cycle",
            "Learn DNS resolution and TCP handshake",
            "Master TLS/SSL encryption process",
            "Debug network issues effectively"
          ],
          "prerequisites": [
            "lesson-what-is-api"
          ],
          "contentHtml": "<h2>HTTP Request/Response Lifecycle</h2>\n\n<p>Let's trace exactly what happens when you make an API call.</p>\n\n<h3>The Complete Journey</h3>\n\n<p>When you call <code>fetch('https://api.example.com/users')</code>:</p>\n\n<ol>\n<li><strong>DNS Resolution</strong>\n<p>Browser/client looks up \"api.example.com\" ‚Üí gets IP address (e.g., 192.0.2.1)</p>\n</li>\n\n<li><strong>TCP Connection</strong>\n<p>Client establishes TCP connection to server (3-way handshake):</p>\n<pre><code>Client: SYN ‚Üí\nServer: SYN-ACK ‚Üí\nClient: ACK ‚Üí\nConnection established!</code></pre>\n</li>\n\n<li><strong>TLS Handshake (HTTPS)</strong>\n<p>Client and server establish encrypted connection:</p>\n<ul>\n<li>Exchange SSL/TLS certificates</li>\n<li>Verify server identity</li>\n<li>Negotiate encryption algorithm</li>\n<li>Exchange encryption keys</li>\n</ul>\n</li>\n\n<li><strong>HTTP Request Sent</strong>\n<pre><code>GET /users HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer abc123\nAccept: application/json</code></pre>\n</li>\n\n<li><strong>Server Processing</strong>\n<ul>\n<li>Parse request</li>\n<li>Authenticate (check token)</li>\n<li>Authorize (check permissions)</li>\n<li>Query database</li>\n<li>Format response</li>\n</ul>\n</li>\n\n<li><strong>HTTP Response Sent</strong>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 256\n\n{\n  \"users\": [...]\n}</code></pre>\n</li>\n\n<li><strong>Connection Handling</strong>\n<p>Connection either:</p>\n<ul>\n<li><strong>Kept alive:</strong> <code>Connection: keep-alive</code> (reuse for next request)</li>\n<li><strong>Closed:</strong> <code>Connection: close</code> (TCP teardown)</li>\n</ul>\n</li>\n</ol>\n\n<h3>Timing Breakdown</h3>\n\n<p>Typical timings for <code>https://api.example.com/users</code>:</p>\n\n<ul>\n<li>DNS lookup: 20-100ms</li>\n<li>TCP handshake: 50-200ms</li>\n<li>TLS handshake: 100-300ms</li>\n<li>Server processing: 50-500ms</li>\n<li>Response download: 10-100ms</li>\n<li><strong>Total: 230-1200ms</strong></li>\n</ul>\n\n<div class='callout callout-tip'>\n<strong>üí° Performance Tip:</strong> The first request is slow (DNS + TCP + TLS). Subsequent requests on the same connection are much faster (just server processing + download).\n</div>\n\n<h3>HTTP/2 and HTTP/3 Improvements</h3>\n\n<ul>\n<li><strong>HTTP/1.1:</strong> One request at a time per connection</li>\n<li><strong>HTTP/2:</strong> Multiple requests simultaneously (multiplexing)</li>\n<li><strong>HTTP/3:</strong> Uses QUIC protocol (faster connection, better for mobile)</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>HTTP requests go through: DNS ‚Üí TCP ‚Üí TLS ‚Üí Request ‚Üí Processing ‚Üí Response</li>\n<li>First request is slow, subsequent requests faster (keep-alive)</li>\n<li>HTTPS adds TLS handshake for encryption</li>\n<li>HTTP/2 and HTTP/3 improve performance</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Why is the first HTTPS request typically slower than subsequent requests?",
              "choices": [
                "The server is warming up",
                "DNS, TCP, and TLS setup only happen once",
                "The first request downloads more data",
                "JSON parsing is slower the first time"
              ],
              "answerIndex": 1,
              "explanation": "The first HTTPS request requires DNS lookup, TCP handshake, and TLS handshake, which are time-consuming. With keep-alive connections, subsequent requests skip these steps and go straight to sending the HTTP request."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Lifecycle",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview"
            }
          ]
        },
        {
          "id": "lesson-http-status-codes-deep",
          "slug": "http-status-codes-complete",
          "title": "HTTP Status Codes: Complete Reference",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Master all HTTP status code categories (1xx-5xx)",
            "Understand when to use each status code",
            "Implement proper error responses",
            "Document status codes for developers"
          ],
          "prerequisites": [
            "lesson-http-status-codes"
          ],
          "contentHtml": "<h2>HTTP Status Codes: Complete Reference</h2>\n\n<p>Status codes communicate what happened with a request. Let's master them all.</p>\n\n<h3>Status Code Categories</h3>\n\n<ul>\n<li><strong>1xx - Informational:</strong> Request received, processing continues</li>\n<li><strong>2xx - Success:</strong> Request successful</li>\n<li><strong>3xx - Redirection:</strong> Further action needed</li>\n<li><strong>4xx - Client Error:</strong> Client made an error</li>\n<li><strong>5xx - Server Error:</strong> Server failed</li>\n</ul>\n\n<h3>2xx Success Codes (Most Important)</h3>\n\n<h4>200 OK</h4>\n<p>Standard success response for GET, PUT, PATCH, DELETE</p>\n<pre><code>GET /api/users/123\n200 OK\n{user data}</code></pre>\n\n<h4>201 Created</h4>\n<p>Resource successfully created (POST)</p>\n<pre><code>POST /api/users\n201 Created\nLocation: /api/users/124\n{new user data}</code></pre>\n\n<h4>204 No Content</h4>\n<p>Success, but no response body (DELETE, empty PUT/PATCH)</p>\n<pre><code>DELETE /api/users/123\n204 No Content\n(empty body)</code></pre>\n\n<h3>4xx Client Errors</h3>\n\n<h4>400 Bad Request</h4>\n<p>Invalid request syntax or validation error</p>\n<pre><code>POST /api/users\n400 Bad Request\n{\n  \"error\": \"Validation failed\",\n  \"details\": {\n    \"email\": \"Invalid email format\"\n  }\n}</code></pre>\n\n<h4>401 Unauthorized</h4>\n<p>Authentication required or failed</p>\n<pre><code>GET /api/users/me\n401 Unauthorized\n{\n  \"error\": \"Invalid or expired token\"\n}</code></pre>\n\n<h4>403 Forbidden</h4>\n<p>Authenticated but not authorized</p>\n<pre><code>DELETE /api/users/999\n403 Forbidden\n{\n  \"error\": \"You don't have permission to delete this user\"\n}</code></pre>\n\n<h4>404 Not Found</h4>\n<p>Resource doesn't exist</p>\n<pre><code>GET /api/users/99999\n404 Not Found\n{\n  \"error\": \"User not found\"\n}</code></pre>\n\n<h4>409 Conflict</h4>\n<p>Request conflicts with current state</p>\n<pre><code>POST /api/users\n409 Conflict\n{\n  \"error\": \"User with this email already exists\"\n}</code></pre>\n\n<h4>422 Unprocessable Entity</h4>\n<p>Valid syntax but semantic errors</p>\n<pre><code>POST /api/users\n422 Unprocessable Entity\n{\n  \"error\": \"Age must be positive number\"\n}</code></pre>\n\n<h4>429 Too Many Requests</h4>\n<p>Rate limit exceeded</p>\n<pre><code>GET /api/users\n429 Too Many Requests\nRetry-After: 60\n{\n  \"error\": \"Rate limit exceeded. Try again in 60 seconds.\"\n}</code></pre>\n\n<h3>5xx Server Errors</h3>\n\n<h4>500 Internal Server Error</h4>\n<p>Generic server error</p>\n<pre><code>GET /api/users\n500 Internal Server Error\n{\n  \"error\": \"An unexpected error occurred\"\n}</code></pre>\n\n<h4>502 Bad Gateway</h4>\n<p>Upstream server error</p>\n\n<h4>503 Service Unavailable</h4>\n<p>Server temporarily unavailable (maintenance, overload)</p>\n<pre><code>503 Service Unavailable\nRetry-After: 3600\n{\n  \"error\": \"Service under maintenance. Try again in 1 hour.\"\n}</code></pre>\n\n<div class='callout callout-warning'>\n<strong>‚ö†Ô∏è Common Mistake:</strong> Don't return 200 OK with <code>{\"error\": \"...\"}</code> in the body. Use the appropriate 4xx/5xx status code.\n</div>\n\n<h3>Documenting Status Codes</h3>\n\n<p>For each endpoint, document:</p>\n<ul>\n<li>All possible status codes</li>\n<li>What triggers each code</li>\n<li>Response body structure for each</li>\n<li>How to handle errors</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li><strong>2xx:</strong> Success (200 OK, 201 Created, 204 No Content)</li>\n<li><strong>4xx:</strong> Client error (400 Bad Request, 401/403 Auth, 404 Not Found, 429 Rate Limit)</li>\n<li><strong>5xx:</strong> Server error (500, 502, 503)</li>\n<li>Always use appropriate status code, never 200 OK with error message</li>\n<li>Document all possible status codes per endpoint</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the difference between 401 and 403?",
              "choices": [
                "They're the same thing",
                "401 means not authenticated, 403 means authenticated but not authorized",
                "401 is for GET requests, 403 is for POST requests",
                "403 is more severe than 401"
              ],
              "answerIndex": 1,
              "explanation": "401 Unauthorized means you need to authenticate (log in). 403 Forbidden means you're authenticated but don't have permission to access this resource. Authentication ‚â† Authorization."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Status Codes",
              "url": "https://httpstatuses.com/"
            }
          ]
        },
        {
          "id": "lesson-content-negotiation",
          "slug": "content-negotiation",
          "title": "Content Negotiation & Media Types",
          "estimated_time_minutes": 30,
          "learning_objectives": [
            "Understand Accept and Content-Type headers",
            "Implement content negotiation",
            "Support multiple response formats",
            "Handle file uploads and downloads"
          ],
          "prerequisites": [
            "lesson-http-headers"
          ],
          "contentHtml": "<h2>Content Negotiation & Media Types</h2>\n\n<p>APIs can support multiple formats. Let's learn how clients and servers negotiate.</p>\n\n<h3>What is Content Negotiation?</h3>\n\n<p>The process where client and server agree on the format to use:</p>\n\n<ul>\n<li>Client says: \"I can handle JSON or XML\"</li>\n<li>Server responds: \"Here's JSON\"</li>\n</ul>\n\n<h3>Accept Header (Client ‚Üí Server)</h3>\n\n<p>Client tells server what formats it prefers:</p>\n\n<pre><code># I prefer JSON\nAccept: application/json\n\n# I prefer XML\nAccept: application/xml\n\n# I can handle either (JSON preferred)\nAccept: application/json, application/xml;q=0.9\n\n# Quality factors (q): 1.0 = most preferred, 0.1 = least preferred\nAccept: application/json;q=1.0, application/xml;q=0.5</code></pre>\n\n<h3>Content-Type Header</h3>\n\n<p><strong>In Requests:</strong> Format of request body</p>\n<pre><code>POST /api/users\nContent-Type: application/json\n\n{\"name\": \"Alice\"}</code></pre>\n\n<p><strong>In Responses:</strong> Format of response body</p>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\n\n{\"id\": 123, \"name\": \"Alice\"}</code></pre>\n\n<h3>Common Media Types</h3>\n\n<ul>\n<li><code>application/json</code> - JSON data (most common)</li>\n<li><code>application/xml</code> - XML data</li>\n<li><code>text/plain</code> - Plain text</li>\n<li><code>text/html</code> - HTML</li>\n<li><code>multipart/form-data</code> - File uploads</li>\n<li><code>application/octet-stream</code> - Binary files</li>\n<li><code>image/jpeg</code>, <code>image/png</code> - Images</li>\n</ul>\n\n<h3>File Uploads (multipart/form-data)</h3>\n\n<pre><code>POST /api/videos/upload\nContent-Type: multipart/form-data; boundary=----Boundary123\n\n------Boundary123\nContent-Disposition: form-data; name=\"title\"\n\nMy Video\n------Boundary123\nContent-Disposition: form-data; name=\"file\"; filename=\"video.mp4\"\nContent-Type: video/mp4\n\n[binary data]\n------Boundary123--</code></pre>\n\n<h3>File Downloads</h3>\n\n<pre><code>GET /api/videos/123/download\n\nHTTP/1.1 200 OK\nContent-Type: video/mp4\nContent-Disposition: attachment; filename=\"my-video.mp4\"\nContent-Length: 15728640\n\n[binary data]</code></pre>\n\n<div class='callout callout-tip'>\n<strong>üí° API Design Tip:</strong> If you support multiple formats (JSON, XML, CSV), document clearly which endpoints support which formats.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Accept header: client specifies preferred response format</li>\n<li>Content-Type header: specifies body format (request/response)</li>\n<li>application/json is most common for REST APIs</li>\n<li>multipart/form-data for file uploads</li>\n<li>Document supported media types per endpoint</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which Content-Type should you use when uploading a file?",
              "choices": [
                "application/json",
                "application/octet-stream",
                "multipart/form-data",
                "text/plain"
              ],
              "answerIndex": 2,
              "explanation": "multipart/form-data is used for file uploads, allowing you to send files along with other form fields in a single request. Each part has its own Content-Type and content."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "Content Negotiation",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation"
            }
          ]
        },
        {
          "id": "lesson-http-methods-deep",
          "slug": "http-methods-deep-dive",
          "title": "HTTP Methods: Complete Deep Dive",
          "estimated_time_minutes": 45,
          "learning_objectives": [
            "Master all HTTP methods (GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD)",
            "Understand safe vs unsafe and idempotent vs non-idempotent operations",
            "Learn when to use PUT vs PATCH for updates",
            "Apply method best practices in API design"
          ],
          "prerequisites": [
            "lesson-what-is-api"
          ],
          "contentHtml": "<h2>HTTP Methods: Complete Deep Dive</h2>\n\n<p>HTTP methods are the foundation. Let's master them completely.</p>\n\n<p><em>[This is the detailed lesson content added earlier - including all the GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD explanations with idempotency, examples, etc.]</em></p>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li><strong>GET:</strong> Retrieve (safe, idempotent)</li>\n<li><strong>POST:</strong> Create (not idempotent)</li>\n<li><strong>PUT:</strong> Replace entire resource (idempotent)</li>\n<li><strong>PATCH:</strong> Partial update (usually idempotent)</li>\n<li><strong>DELETE:</strong> Remove (idempotent)</li>\n<li><strong>OPTIONS:</strong> Discover capabilities</li>\n<li><strong>HEAD:</strong> Get headers only</li>\n</ul>\n</div>\n",
          "examples": [
            {
              "title": "Complete CRUD Operations",
              "language": "javascript",
              "code": "// CREATE - POST\nconst create = await fetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {'Content-Type': 'application/json'},\n  body: JSON.stringify({name: 'Alice', email: 'alice@example.com'})\n});\n\n// READ - GET\nconst read = await fetch('https://api.example.com/users/123');\n\n// UPDATE (partial) - PATCH\nconst update = await fetch('https://api.example.com/users/123', {\n  method: 'PATCH',\n  headers: {'Content-Type': 'application/json'},\n  body: JSON.stringify({email: 'updated@example.com'})\n});\n\n// DELETE\nconst remove = await fetch('https://api.example.com/users/123', {\n  method: 'DELETE'\n});"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which HTTP method is NOT idempotent?",
              "choices": [
                "GET",
                "POST",
                "PUT",
                "DELETE"
              ],
              "answerIndex": 1,
              "explanation": "POST is not idempotent - calling it twice typically creates two resources. GET, PUT, and DELETE are idempotent."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Methods",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods"
            }
          ]
        }
      ]
    },
    {
      "id": "module-authentication",
      "title": "Authentication & Security",
      "description": "Master API security concepts and learn to document authentication methods.",
      "icon": "üîê",
      "lessons": [
        {
          "id": "lesson-auth-basics",
          "slug": "authentication-basics",
          "title": "Authentication vs Authorization",
          "estimated_time_minutes": 32,
          "learning_objectives": [
            "Differentiate between authentication and authorization",
            "Understand common authentication methods (API Keys, OAuth, JWT)",
            "Document authentication requirements clearly",
            "Write security best practices for API users"
          ],
          "prerequisites": [
            "lesson-http-methods"
          ],
          "contentHtml": "<h3>Authentication vs Authorization</h3><p>These terms are often confused, but they serve different purposes:</p><h4>Authentication üîë</h4><p><strong>\"Who are you?\"</strong></p><p>Authentication verifies the identity of the user or application making the request.</p><ul><li>Example: Logging in with username/password</li><li>Example: Providing an API key</li></ul><h4>Authorization üö™</h4><p><strong>\"What are you allowed to do?\"</strong></p><p>Authorization determines what resources the authenticated user can access.</p><ul><li>Example: A user can view their own videos but can't delete another user's videos</li><li>Example: Admin role has more permissions than regular user role</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Think of authentication as showing your ID at the door, and authorization as having the right ticket for the VIP section.</div><h3>Common Authentication Methods</h3><h4>1. API Keys üîë</h4><p>The simplest form of authentication. The client sends a secret key with each request.</p><p><strong>Pros:</strong></p><ul><li>Simple to implement</li><li>Good for server-to-server communication</li></ul><p><strong>Cons:</strong></p><ul><li>Less secure (key can be stolen)</li><li>No granular permissions</li><li>Difficult to revoke for individual users</li></ul><h4>2. OAuth 2.0 üé´</h4><p>A standard protocol for authorization, commonly used for third-party access.</p><p><strong>Pros:</strong></p><ul><li>Industry standard</li><li>Supports scopes (granular permissions)</li><li>Token-based (can expire and refresh)</li></ul><p><strong>Cons:</strong></p><ul><li>More complex to implement</li><li>Requires understanding of flows (authorization code, client credentials, etc.)</li></ul><h4>3. JWT (JSON Web Tokens) üéüÔ∏è</h4><p>Self-contained tokens that include user information and claims.</p><p><strong>Pros:</strong></p><ul><li>Stateless (server doesn't need to store session data)</li><li>Can include custom claims</li><li>Works well with microservices</li></ul><p><strong>Cons:</strong></p><ul><li>Cannot be invalidated before expiry (unless using a blacklist)</li><li>Larger payload than simple tokens</li></ul><h3>Documenting Authentication</h3><p>When documenting authentication, always include:</p><ol><li><strong>Method Used:</strong> API Key, OAuth, JWT, etc.</li><li><strong>How to Obtain:</strong> Where users get their credentials</li><li><strong>Where to Send:</strong> Header name, query parameter, etc.</li><li><strong>Format:</strong> Exact format required (e.g., \"Bearer {token}\")</li><li><strong>Security Best Practices:</strong> Never commit keys to version control, rotate regularly, etc.</li></ol><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Never include real API keys in documentation examples. Use placeholders like \"YOUR_API_KEY\" or \"sk_test_xxxx\".</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>Authentication = \"Who are you?\" | Authorization = \"What can you do?\"</li><li>Common methods: API Keys (simple), OAuth (standard), JWT (stateless)</li><li>Document: method, how to obtain, where to send, format, security tips</li></ul></div>",
          "examples": [
            {
              "title": "API Key in Header",
              "language": "bash",
              "code": "curl -X GET 'https://api.videodb.io/v1/videos' \\\n  -H 'Authorization: Bearer YOUR_API_KEY'"
            },
            {
              "title": "API Key in Python",
              "language": "python",
              "code": "import requests\n\nheaders = {\n    'Authorization': 'Bearer YOUR_API_KEY'\n}\n\nresponse = requests.get(\n    'https://api.videodb.io/v1/videos',\n    headers=headers\n)\n\nprint(response.json())"
            },
            {
              "title": "OAuth 2.0 Access Token",
              "language": "bash",
              "code": "# First, obtain an access token\ncurl -X POST 'https://api.videodb.io/oauth/token' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'grant_type=client_credentials' \\\n  -d 'client_id=YOUR_CLIENT_ID' \\\n  -d 'client_secret=YOUR_CLIENT_SECRET'\n\n# Then use the token in requests\ncurl -X GET 'https://api.videodb.io/v1/videos' \\\n  -H 'Authorization: Bearer ACCESS_TOKEN'"
            },
            {
              "title": "JWT Token Structure",
              "language": "text",
              "code": "Header:  {\"alg\": \"HS256\", \"typ\": \"JWT\"}\nPayload: {\"sub\": \"user123\", \"exp\": 1516239022}\nSignature: HMACSHA256(base64(header) + '.' + base64(payload), secret)"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the difference between authentication and authorization?",
              "choices": [
                "They are the same thing",
                "Authentication verifies identity, authorization determines permissions",
                "Authentication is for users, authorization is for servers",
                "Authorization comes before authentication"
              ],
              "answerIndex": 1,
              "explanation": "Authentication verifies WHO you are (identity), while authorization determines WHAT you can do (permissions)."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Which authentication method is stateless and self-contained?",
              "choices": [
                "API Keys",
                "OAuth 2.0",
                "JWT",
                "Session cookies"
              ],
              "answerIndex": 2,
              "explanation": "JWT (JSON Web Tokens) are stateless because they contain all the necessary information and don't require server-side session storage."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'Authentication vs Authorization', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'Authentication vs Authorization', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'Authentication vs Authorization', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "OAuth 2.0 Simplified",
              "url": "https://aaronparecki.com/oauth-2-simplified/"
            },
            {
              "type": "article",
              "title": "JWT Introduction",
              "url": "https://jwt.io/introduction"
            },
            {
              "type": "youtube",
              "title": "OAuth 2.0 and OpenID Connect (in plain English)",
              "url": "https://www.youtube.com/watch?v=996OiexHze0"
            }
          ]
        },
        {
          "id": "lesson-api-keys",
          "slug": "api-keys-bearer-tokens",
          "title": "API Keys & Bearer Tokens",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Understand how API keys work and when to use them",
            "Learn Bearer token authentication",
            "Implement secure token handling",
            "Document authentication clearly for developers"
          ],
          "prerequisites": [
            "lesson-auth-vs-authz"
          ],
          "contentHtml": "<h2>API Keys & Bearer Tokens</h2>\n\n<p>API keys and bearer tokens are the most common authentication methods. Let's master them.</p>\n\n<h3>API Keys: The Basics</h3>\n\n<p>An <strong>API key</strong> is a unique identifier that authenticates requests:</p>\n\n<pre><code>GET /api/videos HTTP/1.1\nHost: api.videodb.io\nX-API-Key: sk_live_abc123def456ghi789</code></pre>\n\n<p><strong>Common Patterns:</strong></p>\n<ul>\n<li>Header: <code>X-API-Key</code> or <code>API-Key</code></li>\n<li>Query parameter: <code>?api_key=abc123</code> (less secure!)</li>\n<li>Basic Auth username: <code>Authorization: Basic {base64(api_key:)}</code></li>\n</ul>\n\n<h3>Bearer Tokens</h3>\n\n<p><strong>Bearer tokens</strong> are passed in the Authorization header:</p>\n\n<pre><code>GET /api/users/me HTTP/1.1\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>\n\n<p>Bearer tokens are often <strong>JWTs (JSON Web Tokens)</strong> containing encoded user info.</p>\n\n<h3>Security Best Practices</h3>\n\n<ul>\n<li>‚úÖ Always use HTTPS (never send keys over HTTP)</li>\n<li>‚úÖ Store keys in environment variables, never hardcode</li>\n<li>‚úÖ Rotate keys regularly</li>\n<li>‚úÖ Use different keys for dev/staging/production</li>\n<li>‚úÖ Implement rate limiting per API key</li>\n<li>‚ùå Never commit keys to Git</li>\n<li>‚ùå Never log full keys (log last 4 chars only)</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>API keys identify the calling application</li>\n<li>Bearer tokens often contain encoded user data (JWT)</li>\n<li>Always use HTTPS and environment variables</li>\n<li>Document where/how to pass authentication credentials</li>\n</ul>\n</div>\n",
          "examples": [
            {
              "title": "API Key Authentication",
              "language": "javascript",
              "code": "const API_KEY = process.env.VIDEODB_API_KEY; // From environment\n\nconst response = await fetch('https://api.videodb.io/v1/videos', {\n  method: 'GET',\n  headers: {\n    'X-API-Key': API_KEY,\n    'Content-Type': 'application/json'\n  }\n});\n\nconst data = await response.json();"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Where should API keys be stored in production code?",
              "choices": [
                "Hardcoded in the source code",
                "In environment variables or secrets manager",
                "In frontend JavaScript files",
                "In Git repository"
              ],
              "answerIndex": 1,
              "explanation": "API keys should be stored in environment variables or a secrets manager, never hardcoded or committed to version control. This prevents accidental exposure."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "API Key Best Practices",
              "url": "https://cloud.google.com/docs/authentication/api-keys"
            }
          ]
        },
        {
          "id": "lesson-oauth",
          "slug": "oauth-2-flows",
          "title": "OAuth 2.0 Authentication Flows",
          "estimated_time_minutes": 45,
          "learning_objectives": [
            "Understand OAuth 2.0 and when to use it",
            "Learn the Authorization Code flow",
            "Understand Client Credentials flow",
            "Document OAuth flows for developers"
          ],
          "prerequisites": [
            "lesson-auth-vs-authz"
          ],
          "contentHtml": "<h2>OAuth 2.0 Authentication Flows</h2>\n\n<p>OAuth 2.0 is the industry-standard protocol for authorization. Let's understand it properly.</p>\n\n<h3>What is OAuth 2.0?</h3>\n\n<p>OAuth 2.0 allows users to grant third-party applications limited access to their resources <strong>without sharing passwords</strong>.</p>\n\n<p><strong>Example:</strong> \"Sign in with Google\" - the app gets access to your Google profile without knowing your Google password.</p>\n\n<h3>Key Concepts</h3>\n\n<ul>\n<li><strong>Resource Owner:</strong> The user who owns the data</li>\n<li><strong>Client:</strong> The application requesting access</li>\n<li><strong>Authorization Server:</strong> Issues access tokens (e.g., Google's OAuth server)</li>\n<li><strong>Resource Server:</strong> Hosts the protected resources (API server)</li>\n<li><strong>Access Token:</strong> Credential used to access protected resources</li>\n<li><strong>Refresh Token:</strong> Used to get new access tokens when they expire</li>\n</ul>\n\n<h3>Authorization Code Flow (Most Common)</h3>\n\n<p>Used for web apps where the backend can securely store secrets:</p>\n\n<pre><code>1. User clicks \"Sign in with Google\"\n2. App redirects to Google's authorization page\n3. User logs in and approves access\n4. Google redirects back with authorization code\n5. App exchanges code for access token (server-side)\n6. App uses access token to call APIs</code></pre>\n\n<h3>Client Credentials Flow</h3>\n\n<p>Used for machine-to-machine authentication (no user involved):</p>\n\n<pre><code>POST /oauth/token HTTP/1.1\nHost: auth.example.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n&client_id=YOUR_CLIENT_ID\n&client_secret=YOUR_CLIENT_SECRET\n\nResponse:\n{\n  \"access_token\": \"eyJhbGci...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600\n}</code></pre>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>OAuth 2.0 enables secure delegated access</li>\n<li>Authorization Code flow: for user-facing web apps</li>\n<li>Client Credentials flow: for server-to-server</li>\n<li>Never expose client secrets in frontend code</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the main benefit of OAuth 2.0?",
              "choices": [
                "It makes APIs faster",
                "Users can grant access without sharing passwords",
                "It eliminates the need for HTTPS",
                "It's easier to implement than API keys"
              ],
              "answerIndex": 1,
              "explanation": "OAuth 2.0's main benefit is allowing users to grant third-party apps access to their resources without sharing passwords. This is more secure and gives users control over what they share."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "OAuth 2.0 Simplified",
              "url": "https://aaronparecki.com/oauth-2-simplified/"
            }
          ]
        },
        {
          "id": "lesson-api-security",
          "slug": "api-security-best-practices",
          "title": "API Security Best Practices",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Learn HTTPS/TLS requirements",
            "Understand input validation and sanitization",
            "Implement rate limiting and CORS",
            "Document security requirements clearly"
          ],
          "prerequisites": [
            "lesson-api-keys"
          ],
          "contentHtml": "<h2>API Security Best Practices</h2>\n\n<p>Security is non-negotiable for APIs. Let's cover essential practices.</p>\n\n<h3>1. Always Use HTTPS</h3>\n\n<p><strong>Never</strong> send sensitive data over HTTP. HTTPS encrypts traffic using TLS.</p>\n\n<ul>\n<li>‚úÖ <code>https://api.example.com</code></li>\n<li>‚ùå <code>http://api.example.com</code></li>\n</ul>\n\n<h3>2. Input Validation</h3>\n\n<p>Validate and sanitize all input to prevent injection attacks:</p>\n\n<ul>\n<li>Check data types (is age really a number?)</li>\n<li>Validate ranges (age between 0-150)</li>\n<li>Sanitize strings (remove SQL/script injection attempts)</li>\n<li>Limit input length (prevent buffer overflow)</li>\n</ul>\n\n<h3>3. Rate Limiting</h3>\n\n<p>Prevent abuse by limiting requests per time window:</p>\n\n<pre><code>HTTP/1.1 429 Too Many Requests\nX-RateLimit-Limit: 100\nX-RateLimit-Remaining: 0\nX-RateLimit-Reset: 1640000000\n\n{\n  \"error\": \"Rate limit exceeded. Try again in 60 seconds.\"\n}</code></pre>\n\n<h3>4. CORS (Cross-Origin Resource Sharing)</h3>\n\n<p>Control which domains can access your API from browsers:</p>\n\n<pre><code>Access-Control-Allow-Origin: https://yourapp.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: Authorization, Content-Type</code></pre>\n\n<div class='callout callout-warning'>\n<strong>‚ö†Ô∏è Security Warning:</strong> Never use <code>Access-Control-Allow-Origin: *</code> for APIs requiring authentication. This allows ANY website to make authenticated requests from users' browsers.\n</div>\n\n<h3>5. Sensitive Data in Documentation</h3>\n\n<p>When writing docs:</p>\n\n<ul>\n<li>‚úÖ Show example keys: <code>sk_test_abc123...</code> (clearly fake)</li>\n<li>‚úÖ Warn developers to use environment variables</li>\n<li>‚úÖ Explain token expiration and rotation</li>\n<li>‚ùå Never include real API keys in examples</li>\n<li>‚ùå Don't minimize security requirements</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>HTTPS is mandatory for all production APIs</li>\n<li>Validate and sanitize all user input</li>\n<li>Implement rate limiting to prevent abuse</li>\n<li>Configure CORS properly for browser requests</li>\n<li>Document security requirements prominently</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Why should you never use HTTP (only HTTPS) for APIs?",
              "choices": [
                "HTTP is slower than HTTPS",
                "HTTP doesn't support JSON",
                "HTTP transmits data in plain text, exposing sensitive information",
                "HTTP is an older protocol"
              ],
              "answerIndex": 2,
              "explanation": "HTTP transmits data in plain text, making it easy for attackers to intercept sensitive information like API keys and user data. HTTPS encrypts all traffic using TLS, protecting data in transit."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "OWASP API Security Top 10",
              "url": "https://owasp.org/www-project-api-security/"
            }
          ]
        }
      ]
    },
    {
      "id": "module-openapi-reference",
      "title": "OpenAPI Specification",
      "description": "Learn to create API reference documentation and master OpenAPI specification.",
      "icon": "üìò",
      "lessons": [
        {
          "id": "lesson-openapi-intro",
          "slug": "openapi-introduction",
          "title": "Introduction to OpenAPI Specification",
          "estimated_time_minutes": 39,
          "learning_objectives": [
            "Understand the purpose and benefits of OpenAPI",
            "Identify the key components of an OpenAPI document",
            "Write a basic OpenAPI 3.0 specification",
            "Use OpenAPI tools for documentation generation"
          ],
          "prerequisites": [
            "lesson-http-methods"
          ],
          "contentHtml": "<h3>What is OpenAPI?</h3><p><strong>OpenAPI Specification</strong> (formerly Swagger) is a standard, language-agnostic format for describing REST APIs. Think of it as a contract that defines your API's structure.</p><h3>Why Use OpenAPI?</h3><ul><li>‚úÖ <strong>Auto-generate documentation:</strong> Tools like Swagger UI create interactive docs from your spec</li><li>‚úÖ <strong>Generate client SDKs:</strong> Automatically create client libraries in multiple languages</li><li>‚úÖ <strong>API validation:</strong> Ensure requests/responses match the specification</li><li>‚úÖ <strong>Version control:</strong> Track API changes over time</li><li>‚úÖ <strong>Standardization:</strong> Team-wide consistency</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Write your OpenAPI spec BEFORE building the API. It serves as a design document and contract.</div><h3>OpenAPI Document Structure</h3><p>An OpenAPI document has three main sections:</p><h4>1. Info Section</h4><p>Metadata about your API:</p><pre><code class='language-yaml'>openapi: 3.0.0\ninfo:\n  title: VideoDB API\n  version: 1.0.0\n  description: API for managing video databases\n  contact:\n    name: API Support\n    email: support@videodb.io</code></pre><h4>2. Servers</h4><p>Define where the API is hosted:</p><pre><code class='language-yaml'>servers:\n  - url: https://api.videodb.io/v1\n    description: Production server\n  - url: https://sandbox.videodb.io/v1\n    description: Sandbox environment</code></pre><h4>3. Paths (Endpoints)</h4><p>The actual API endpoints:</p><pre><code class='language-yaml'>paths:\n  /videos:\n    get:\n      summary: List all videos\n      responses:\n        '200':\n          description: Success</code></pre><h3>Key Components</h3><table style='width:100%; border-collapse: collapse; margin: 1rem 0;'><tr style='background: #f0f0f0;'><th style='padding: 0.5rem; border: 1px solid #ddd;'>Component</th><th style='padding: 0.5rem; border: 1px solid #ddd;'>Purpose</th></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>paths</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Define API endpoints</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>components</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Reusable schemas, parameters, responses</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>security</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Authentication methods</td></tr><tr><td style='padding: 0.5rem; border: 1px solid #ddd;'>tags</td><td style='padding: 0.5rem; border: 1px solid #ddd;'>Group related operations</td></tr></table><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't confuse OpenAPI 2.0 (Swagger) with OpenAPI 3.0+. The syntax is different. Use OpenAPI 3.0 or higher for new projects.</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>OpenAPI = standardized API description format</li><li>Benefits: auto-docs, client generation, validation</li><li>Structure: info, servers, paths, components</li><li>Write the spec first as a design contract</li></ul></div>",
          "examples": [
            {
              "title": "Complete OpenAPI 3.0 Example",
              "language": "yaml",
              "code": "openapi: 3.0.0\ninfo:\n  title: VideoDB API\n  version: 1.0.0\n  description: Manage your video database\n\nservers:\n  - url: https://api.videodb.io/v1\n\npaths:\n  /videos/{videoId}:\n    get:\n      summary: Get a video by ID\n      parameters:\n        - name: videoId\n          in: path\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Video'\n        '404':\n          description: Video not found\n\ncomponents:\n  schemas:\n    Video:\n      type: object\n      properties:\n        id:\n          type: string\n        title:\n          type: string\n        duration:\n          type: integer\n          description: Duration in seconds"
            },
            {
              "title": "Security Scheme (API Key)",
              "language": "yaml",
              "code": "components:\n  securitySchemes:\n    ApiKeyAuth:\n      type: apiKey\n      in: header\n      name: Authorization\n\nsecurity:\n  - ApiKeyAuth: []"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What is the current recommended version of OpenAPI for new projects?",
              "choices": [
                "Swagger 2.0",
                "OpenAPI 2.0",
                "OpenAPI 3.0+",
                "REST 1.0"
              ],
              "answerIndex": 2,
              "explanation": "OpenAPI 3.0 (or higher) is the current standard. OpenAPI 2.0 was previously called Swagger."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Based on this lesson about 'Introduction to OpenAPI Specification', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'Introduction to OpenAPI Specification', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'Introduction to OpenAPI Specification', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'Introduction to OpenAPI Specification', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "website",
              "title": "OpenAPI Specification",
              "url": "https://spec.openapis.org/oas/latest.html"
            },
            {
              "type": "tool",
              "title": "Swagger Editor (Online)",
              "url": "https://editor.swagger.io/"
            }
          ]
        },
        {
          "id": "lesson-openapi-schemas",
          "slug": "openapi-schemas-types",
          "title": "OpenAPI Schemas & Data Types",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Master OpenAPI schema definitions",
            "Use primitive and complex data types",
            "Define reusable components",
            "Validate request/response schemas"
          ],
          "prerequisites": [
            "lesson-openapi-intro"
          ],
          "contentHtml": "<h2>OpenAPI Schemas & Data Types</h2>\n\n<p>Schemas define the structure of request and response data. Let's master them.</p>\n\n<h3>Basic Types</h3>\n\n<pre><code>type: string    # Text\ntype: integer   # Whole numbers\ntype: number    # Decimals (float/double)\ntype: boolean   # true/false\ntype: array     # List of items\ntype: object    # Key-value pairs</code></pre>\n\n<h3>String Formats</h3>\n\n<pre><code>type: string\nformat: date       # 2024-01-15\nformat: date-time  # 2024-01-15T10:30:00Z\nformat: email      # user@example.com\nformat: uri        # https://example.com\nformat: uuid       # 123e4567-e89b-12d3-a456-426614174000</code></pre>\n\n<h3>Objects with Properties</h3>\n\n<pre><code>type: object\nproperties:\n  id:\n    type: integer\n  name:\n    type: string\n  email:\n    type: string\n    format: email\nrequired:\n  - id\n  - name</code></pre>\n\n<h3>Arrays</h3>\n\n<pre><code>type: array\nitems:\n  type: object\n  properties:\n    id:\n      type: integer\n    title:\n      type: string</code></pre>\n\n<h3>Reusable Components</h3>\n\n<p>Define schemas once, reference everywhere:</p>\n\n<pre><code>components:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n\npaths:\n  /users/{id}:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'</code></pre>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Schemas define data structure (types, formats, required fields)</li>\n<li>Use components for reusable schema definitions</li>\n<li>Validate request/response data against schemas</li>\n<li>Clear schemas make APIs self-documenting</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the benefit of using components/schemas in OpenAPI?",
              "choices": [
                "It makes the API faster",
                "You can reuse definitions instead of repeating them",
                "It's required by the OpenAPI specification",
                "It automatically generates code"
              ],
              "answerIndex": 1,
              "explanation": "Components let you define schemas once and reference them throughout your specification using $ref. This reduces repetition, improves maintainability, and ensures consistency."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "OpenAPI Schema Object",
              "url": "https://swagger.io/specification/#schema-object"
            }
          ]
        }
      ]
    },
    {
      "id": "module-endpoints-params",
      "title": "API Design Patterns",
      "description": "Master documenting API endpoints, request parameters, and comprehensive error handling.",
      "icon": "üóÇÔ∏è",
      "lessons": [
        {
          "id": "lesson-documenting-endpoints",
          "slug": "documenting-endpoints",
          "title": "Documenting API Endpoints",
          "estimated_time_minutes": 39,
          "learning_objectives": [
            "Structure endpoint documentation effectively",
            "Document path, query, and body parameters",
            "Write clear request and response examples",
            "Create comprehensive parameter descriptions"
          ],
          "prerequisites": [
            "lesson-openapi-intro"
          ],
          "contentHtml": "<h3>Anatomy of Endpoint Documentation</h3><p>Every endpoint should include:</p><ol><li>üìç <strong>Endpoint URL</strong> and HTTP method</li><li>üìù <strong>Description</strong> of what it does</li><li>üîë <strong>Authentication</strong> requirements</li><li>üìä <strong>Parameters</strong> (path, query, body)</li><li>‚úÖ <strong>Success responses</strong> with examples</li><li>‚ùå <strong>Error responses</strong> with examples</li><li>üíª <strong>Code examples</strong> in multiple languages</li></ol><h3>Types of Parameters</h3><h4>1. Path Parameters</h4><p>Part of the URL path itself (required):</p><pre><code>GET /videos/{videoId}/comments/{commentId}</code></pre><p><strong>Documentation:</strong></p><ul><li><code>videoId</code> (string, required): The unique identifier of the video</li><li><code>commentId</code> (string, required): The unique identifier of the comment</li></ul><h4>2. Query Parameters</h4><p>Appended to the URL after <code>?</code> (usually optional):</p><pre><code>GET /videos?limit=10&sort=created_desc&category=tech</code></pre><p><strong>Documentation:</strong></p><ul><li><code>limit</code> (integer, optional): Number of results to return (default: 20, max: 100)</li><li><code>sort</code> (string, optional): Sort order (options: created_asc, created_desc, title)</li><li><code>category</code> (string, optional): Filter by category</li></ul><h4>3. Body Parameters</h4><p>Sent in the request body (for POST, PUT, PATCH):</p><pre><code class='language-json'>{\n  \"title\": \"My Video\",\n  \"description\": \"A great video\",\n  \"tags\": [\"education\", \"tutorial\"]\n}</code></pre><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Always specify default values, ranges, and constraints for parameters (e.g., \"max length: 255 characters\").</div><h3>Request & Response Examples</h3><p>Provide complete, realistic examples:</p><h4>‚úÖ Good Example</h4><pre><code class='language-bash'>curl -X POST 'https://api.videodb.io/v1/videos' \\\n  -H 'Authorization: Bearer YOUR_API_KEY' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"title\": \"My First Video\",\n    \"url\": \"https://example.com/video.mp4\",\n    \"tags\": [\"tutorial\"]\n  }'</code></pre><h4>‚ùå Bad Example</h4><pre><code>POST /videos\nSend: title, url\nGet: video object</code></pre><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't just say \"Returns a video object.\" Show the actual JSON structure with example values.</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>Document 7 things: URL, description, auth, params, success, errors, examples</li><li>3 parameter types: path (required), query (optional), body (POST/PUT/PATCH)</li><li>Always provide complete, realistic examples</li></ul></div>",
          "examples": [
            {
              "title": "Full Endpoint Documentation Example",
              "language": "markdown",
              "code": "## POST /videos\n\nCreate a new video in your collection.\n\n### Authentication\nRequires API key in Authorization header.\n\n### Request Body\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| title | string | Yes | Video title (max 255 chars) |\n| url | string | Yes | URL of the video file |\n| description | string | No | Video description |\n| tags | array[string] | No | Tags for categorization |\n\n### Example Request\n\n```bash\ncurl -X POST 'https://api.videodb.io/v1/videos' \\\n  -H 'Authorization: Bearer sk_test_abc123' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"title\": \"Product Demo\",\n    \"url\": \"https://cdn.example.com/demo.mp4\",\n    \"tags\": [\"demo\", \"product\"]\n  }'\n```\n\n### Success Response (201 Created)\n\n```json\n{\n  \"id\": \"vid_xyz789\",\n  \"title\": \"Product Demo\",\n  \"url\": \"https://cdn.example.com/demo.mp4\",\n  \"status\": \"processing\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"tags\": [\"demo\", \"product\"]\n}\n```\n\n### Error Responses\n\n**400 Bad Request** - Invalid input\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Title is required\"\n  }\n}\n```\n\n**401 Unauthorized** - Missing/invalid API key"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which type of parameter is part of the URL path itself?",
              "choices": [
                "Query parameter",
                "Path parameter",
                "Body parameter",
                "Header parameter"
              ],
              "answerIndex": 1,
              "explanation": "Path parameters are embedded in the URL path, like /videos/{videoId}."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Based on this lesson about 'Documenting API Endpoints', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'Documenting API Endpoints', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'Documenting API Endpoints', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'Documenting API Endpoints', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "REST API Best Practices",
              "url": "https://restfulapi.net/resource-naming/"
            }
          ]
        },
        {
          "id": "lesson-pagination",
          "slug": "pagination-strategies",
          "title": "Pagination Strategies",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Understand offset vs cursor pagination",
            "Implement page-based pagination",
            "Document pagination clearly",
            "Handle large datasets efficiently"
          ],
          "prerequisites": [
            "lesson-api-endpoints"
          ],
          "contentHtml": "<h2>Pagination Strategies</h2>\n\n<p>Large datasets need pagination. Let's explore common patterns.</p>\n\n<h3>1. Offset-Based Pagination</h3>\n\n<p>Most common and easiest to implement:</p>\n\n<pre><code>GET /api/videos?page=2&limit=20\n\nResponse:\n{\n  \"data\": [...],\n  \"page\": 2,\n  \"limit\": 20,\n  \"total\": 150,\n  \"total_pages\": 8\n}</code></pre>\n\n<p><strong>Pros:</strong> Simple, can jump to any page<br>\n<strong>Cons:</strong> Performance degrades with high offsets, inconsistent if data changes</p>\n\n<h3>2. Cursor-Based Pagination</h3>\n\n<p>More efficient for large datasets:</p>\n\n<pre><code>GET /api/videos?cursor=eyJpZCI6MTIzfQ&limit=20\n\nResponse:\n{\n  \"data\": [...],\n  \"next_cursor\": \"eyJpZCI6MTQzfQ\",\n  \"has_more\": true\n}</code></pre>\n\n<p><strong>Pros:</strong> Consistent, fast, works well with real-time data<br>\n<strong>Cons:</strong> Can't jump to specific page, only next/previous</p>\n\n<h3>3. Page-Based (Simple)</h3>\n\n<pre><code>GET /api/videos?page=1&per_page=50</code></pre>\n\n<div class='callout callout-tip'>\n<strong>üí° Pro Tip:</strong> Document default pagination limits and maximum allowed values to prevent abuse.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Offset: simple, jump to pages, slower for large datasets</li>\n<li>Cursor: fast, consistent, can't jump to arbitrary pages</li>\n<li>Always include total count and next/previous links</li>\n<li>Document limits and defaults clearly</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Which pagination method is most efficient for very large datasets?",
              "choices": [
                "Offset-based (page + limit)",
                "Cursor-based (cursor + limit)",
                "Page-based (page + per_page)",
                "All are equally efficient"
              ],
              "answerIndex": 1,
              "explanation": "Cursor-based pagination is most efficient for large datasets because it uses indexed fields (like ID) to find the next set, avoiding the performance penalty of high offsets in offset-based pagination."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "Pagination Best Practices",
              "url": "https://specs.openstack.org/openstack/api-wg/guidelines/pagination_filter_sort.html"
            }
          ]
        },
        {
          "id": "lesson-filtering-sorting",
          "slug": "filtering-and-sorting",
          "title": "Filtering & Sorting",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Implement query parameter filtering",
            "Design sorting mechanisms",
            "Combine filters with pagination",
            "Document query parameters clearly"
          ],
          "prerequisites": [
            "lesson-pagination"
          ],
          "contentHtml": "<h2>Filtering & Sorting</h2>\n\n<p>Let users find exactly what they need with powerful filtering and sorting.</p>\n\n<h3>Filtering with Query Parameters</h3>\n\n<pre><code># Single filter\nGET /api/users?role=admin\n\n# Multiple filters (AND logic)\nGET /api/users?role=admin&active=true\n\n# Range filters\nGET /api/products?price_min=10&price_max=100\n\n# Search\nGET /api/videos?search=tutorial\n\n# Date ranges\nGET /api/orders?created_after=2024-01-01&created_before=2024-12-31</code></pre>\n\n<h3>Sorting</h3>\n\n<pre><code># Ascending\nGET /api/users?sort=created_at\n\n# Descending (minus sign)\nGET /api/users?sort=-created_at\n\n# Multiple fields\nGET /api/users?sort=role,-created_at\n\n# Alternative syntax\nGET /api/users?sort_by=created_at&order=desc</code></pre>\n\n<h3>Combining Everything</h3>\n\n<pre><code>GET /api/videos?status=published&sort=-views&page=1&limit=20</code></pre>\n\n<p>This gets published videos, sorted by views (descending), paginated.</p>\n\n<div class='callout callout-tip'>\n<strong>üí° Documentation Tip:</strong> Create a table showing all supported query parameters with examples for each.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Use query parameters for filtering and sorting</li>\n<li>Support common patterns: equals, ranges, search</li>\n<li>Document all supported parameters with examples</li>\n<li>Combine with pagination for complete data access</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What does the minus sign (-) typically mean in sorting?",
              "choices": [
                "Exclude the field",
                "Sort in ascending order",
                "Sort in descending order",
                "Make the field optional"
              ],
              "answerIndex": 2,
              "explanation": "In many APIs, a minus sign (-) before a field name indicates descending order. For example, sort=-created_at means sort by created_at from newest to oldest."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "API Query Patterns",
              "url": "https://jsonapi.org/format/#fetching-filtering"
            }
          ]
        },
        {
          "id": "lesson-versioning",
          "slug": "api-versioning-deprecation",
          "title": "API Versioning & Deprecation",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Understand why versioning is necessary",
            "Learn URL vs header versioning",
            "Implement deprecation warnings",
            "Document version changes clearly"
          ],
          "prerequisites": [
            "lesson-rest-principles"
          ],
          "contentHtml": "<h2>API Versioning & Deprecation</h2>\n\n<p>APIs evolve. Versioning allows changes without breaking existing integrations.</p>\n\n<h3>Why Version?</h3>\n\n<p>Without versioning, changing your API breaks all existing clients. Versioning lets you:</p>\n<ul>\n<li>Introduce breaking changes safely</li>\n<li>Give developers time to migrate</li>\n<li>Support multiple versions simultaneously</li>\n</ul>\n\n<h3>URL Versioning (Most Common)</h3>\n\n<pre><code>GET /v1/users\nGET /v2/users\nGET /v3/users</code></pre>\n\n<p><strong>Pros:</strong> Clear, simple, easy to route<br>\n<strong>Cons:</strong> Pollutes URL namespace</p>\n\n<h3>Header Versioning</h3>\n\n<pre><code>GET /users\nAccept: application/vnd.myapi.v2+json</code></pre>\n\n<p><strong>Pros:</strong> Keeps URLs clean<br>\n<strong>Cons:</strong> Less visible, harder to test in browser</p>\n\n<h3>Deprecation Warnings</h3>\n\n<p>When sunsetting an endpoint:</p>\n\n<pre><code>HTTP/1.1 200 OK\nSunset: Sat, 31 Dec 2024 23:59:59 GMT\nDeprecation: true\nLink: <https://docs.example.com/migration>; rel=\"deprecation\"\n\n{\n  \"warning\": \"This endpoint is deprecated and will be removed on 2024-12-31. Use /v3/users instead.\"\n}</code></pre>\n\n<h3>Documenting Changes</h3>\n\n<p>Maintain a changelog showing:</p>\n<ul>\n<li>What changed in each version</li>\n<li>Breaking vs non-breaking changes</li>\n<li>Migration guides</li>\n<li>Deprecation timelines</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Versioning enables API evolution without breaking clients</li>\n<li>URL versioning is most common and visible</li>\n<li>Announce deprecations early with sunset dates</li>\n<li>Provide clear migration guides in documentation</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the main benefit of API versioning?",
              "choices": [
                "Makes the API faster",
                "Allows changes without breaking existing clients",
                "Reduces server costs",
                "Eliminates the need for documentation"
              ],
              "answerIndex": 1,
              "explanation": "API versioning allows you to make breaking changes to your API while keeping old versions running, giving existing clients time to migrate without sudden breakage."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "API Versioning Best Practices",
              "url": "https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/"
            }
          ]
        }
      ]
    },
    {
      "id": "module-tools-workflows",
      "title": "Documentation Craft",
      "description": "Master Postman, cURL, YAML validation, and API testing workflows.",
      "icon": "üß∞",
      "lessons": [
        {
          "id": "lesson-postman-curl",
          "slug": "postman-curl-testing",
          "title": "API Testing with Postman & cURL",
          "estimated_time_minutes": 39,
          "learning_objectives": [
            "Use cURL for command-line API testing",
            "Create and organize requests in Postman",
            "Generate code snippets from Postman",
            "Validate API responses"
          ],
          "prerequisites": [
            "lesson-http-methods"
          ],
          "contentHtml": "<h3>Why Test Your API?</h3><p>Before documenting an endpoint, you must <strong>test it</strong> to understand:</p><ul><li>What parameters are actually required</li><li>What the real response looks like</li><li>What errors can occur</li><li>Edge cases and validation rules</li></ul><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Never document an API endpoint you haven't tested yourself. You'll miss crucial details.</div><h3>cURL: Command-Line Testing</h3><p><strong>cURL</strong> is a command-line tool for making HTTP requests. It's universal and works everywhere.</p><h4>Basic cURL Commands</h4><pre><code class='language-bash'># GET request\ncurl https://api.videodb.io/v1/videos\n\n# GET with headers\ncurl -H \"Authorization: Bearer TOKEN\" \\\n  https://api.videodb.io/v1/videos\n\n# POST with JSON data\ncurl -X POST https://api.videodb.io/v1/videos \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer TOKEN\" \\\n  -d '{\"title\":\"My Video\"}'\n\n# Pretty-print JSON response (with jq)\ncurl https://api.videodb.io/v1/videos | jq\n\n# Save response to file\ncurl -o response.json https://api.videodb.io/v1/videos</code></pre><h3>Postman: Visual API Testing</h3><p><strong>Postman</strong> is a GUI tool for testing APIs. It's perfect for:</p><ul><li>Organizing requests into collections</li><li>Saving and reusing requests</li><li>Auto-generating code snippets</li><li>Team collaboration</li><li>Automated testing</li></ul><h4>Postman Workflow</h4><ol><li><strong>Create a collection:</strong> Group related requests</li><li><strong>Add requests:</strong> Define method, URL, headers, body</li><li><strong>Set environment variables:</strong> Store API keys, base URLs</li><li><strong>Test:</strong> Run requests and inspect responses</li><li><strong>Generate code:</strong> Export to cURL, Python, JavaScript, etc.</li><li><strong>Share:</strong> Export collection for team members</li></ol><h3>Code Generation from Postman</h3><p>Postman can generate code in 20+ languages:</p><ol><li>Create your request in Postman</li><li>Click \"Code\" button (</>) </li><li>Select language (cURL, Python, JavaScript, etc.)</li><li>Copy & paste into your documentation</li></ol><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't forget to remove real API keys before pasting code into documentation!</div><h3>Best Practices for Testing</h3><ul><li>‚úÖ Test both success and error scenarios</li><li>‚úÖ Try invalid parameters to see error messages</li><li>‚úÖ Test edge cases (empty strings, very long values, special characters)</li><li>‚úÖ Document the exact request that worked</li><li>‚úÖ Save example responses as they appear in reality</li></ul><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>Always test endpoints before documenting</li><li>cURL = command-line, universal</li><li>Postman = GUI, great for organization and code generation</li><li>Test success, errors, and edge cases</li></ul></div>",
          "examples": [
            {
              "title": "cURL GET Request",
              "language": "bash",
              "code": "curl -X GET 'https://api.videodb.io/v1/videos/abc123' \\\n  -H 'Authorization: Bearer YOUR_API_KEY' \\\n  -H 'Accept: application/json'"
            },
            {
              "title": "cURL POST Request",
              "language": "bash",
              "code": "curl -X POST 'https://api.videodb.io/v1/videos' \\\n  -H 'Authorization: Bearer YOUR_API_KEY' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"title\": \"My New Video\",\n    \"url\": \"https://example.com/video.mp4\"\n  }'"
            },
            {
              "title": "Postman Environment Variables",
              "language": "json",
              "code": "{\n  \"name\": \"VideoDB Production\",\n  \"values\": [\n    {\n      \"key\": \"base_url\",\n      \"value\": \"https://api.videodb.io/v1\",\n      \"enabled\": true\n    },\n    {\n      \"key\": \"api_key\",\n      \"value\": \"sk_live_abc123\",\n      \"enabled\": true,\n      \"type\": \"secret\"\n    }\n  ]\n}"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What is the primary advantage of cURL over GUI tools?",
              "choices": [
                "It's faster",
                "It works in any terminal/script",
                "It has better error messages",
                "It's easier to use"
              ],
              "answerIndex": 1,
              "explanation": "cURL is universal and works in any terminal, script, or CI/CD pipeline, making it highly portable."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Based on this lesson about 'API Testing with Postman & cURL', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'API Testing with Postman & cURL', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'API Testing with Postman & cURL', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'API Testing with Postman & cURL', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "tool",
              "title": "Postman Download",
              "url": "https://www.postman.com/downloads/"
            },
            {
              "type": "article",
              "title": "cURL Cheat Sheet",
              "url": "https://devhints.io/curl"
            }
          ]
        },
        {
          "id": "lesson-writing-docs",
          "slug": "writing-clear-documentation",
          "title": "Writing Clear API Documentation",
          "estimated_time_minutes": 45,
          "learning_objectives": [
            "Master documentation structure and organization",
            "Write clear, concise technical content",
            "Create effective code examples",
            "Understand developer personas and needs"
          ],
          "prerequisites": [],
          "contentHtml": "<h2>Writing Clear API Documentation</h2>\n\n<p>Great documentation is your API's superpower. Let's learn to write it well.</p>\n\n<h3>Documentation Structure</h3>\n\n<p>Every API doc should have:</p>\n\n<ol>\n<li><strong>Getting Started / Quickstart</strong> - get developers to \"Hello World\" fast</li>\n<li><strong>Authentication</strong> - how to authenticate requests</li>\n<li><strong>Core Concepts</strong> - key ideas developers need to understand</li>\n<li><strong>API Reference</strong> - exhaustive endpoint documentation</li>\n<li><strong>Guides & Tutorials</strong> - common workflows and use cases</li>\n<li><strong>Error Reference</strong> - all error codes explained</li>\n<li><strong>SDKs & Tools</strong> - client libraries and tools</li>\n<li><strong>Changelog</strong> - version history and updates</li>\n</ol>\n\n<h3>Writing Principles</h3>\n\n<h4>1. Be Concise</h4>\n<p>‚ùå Bad: \"In order to retrieve the comprehensive list of all users currently registered within the system, you will need to send an HTTP GET request...\"</p>\n<p>‚úÖ Good: \"Get all users with <code>GET /users</code>.\"</p>\n\n<h4>2. Use Active Voice</h4>\n<p>‚ùå Passive: \"A request is sent to the API by the client.\"</p>\n<p>‚úÖ Active: \"The client sends a request to the API.\"</p>\n\n<h4>3. Show, Don't Just Tell</h4>\n<p>Every concept needs a code example. Developers copy-paste examples.</p>\n\n<h4>4. Anticipate Questions</h4>\n<p>Think: \"What would I want to know if I was using this for the first time?\"</p>\n\n<h3>The Perfect Endpoint Documentation</h3>\n\n<p>Each endpoint should have:</p>\n\n<ul>\n<li><strong>Title:</strong> Clear, descriptive name</li>\n<li><strong>Description:</strong> What it does, when to use it</li>\n<li><strong>HTTP Method & URL:</strong> <code>POST /v1/videos</code></li>\n<li><strong>Authentication:</strong> Required auth method</li>\n<li><strong>Parameters:</strong> Path, query, body params with types, required/optional, defaults</li>\n<li><strong>Request Example:</strong> Complete, runnable example</li>\n<li><strong>Response Example:</strong> Successful response structure</li>\n<li><strong>Error Responses:</strong> Common errors (400, 401, 404, 500) with examples</li>\n<li><strong>Notes:</strong> Rate limits, special cases, edge cases</li>\n</ul>\n\n<h3>Code Example Best Practices</h3>\n\n<ul>\n<li>‚úÖ Show multiple languages (cURL, JavaScript, Python)</li>\n<li>‚úÖ Use realistic data (not \"foo\", \"bar\", \"test\")</li>\n<li>‚úÖ Include authentication</li>\n<li>‚úÖ Make examples copy-pasteable</li>\n<li>‚úÖ Show complete requests AND responses</li>\n<li>‚ùå Don't use real API keys (use <code>YOUR_API_KEY</code>)</li>\n</ul>\n\n<h3>Understanding Your Audience</h3>\n\n<p>Write for different developer personas:</p>\n\n<ul>\n<li><strong>The Beginner:</strong> Needs hand-holding, clear explanations</li>\n<li><strong>The Experienced:</strong> Wants quick reference, skimmable content</li>\n<li><strong>The Troubleshooter:</strong> Searching for specific error solutions</li>\n</ul>\n\n<p>Your docs should serve all three.</p>\n\n<div class='callout callout-tip'>\n<strong>üí° Pro Tip:</strong> Test your docs by having someone unfamiliar try to integrate. Watch where they get stuck.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Structure: Getting Started ‚Üí Auth ‚Üí Concepts ‚Üí Reference ‚Üí Guides</li>\n<li>Write concisely, use active voice, show examples</li>\n<li>Every endpoint needs: description, params, examples, errors</li>\n<li>Make examples copy-pasteable and realistic</li>\n<li>Write for beginners, experienced devs, and troubleshooters</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the most important section for new developers?",
              "choices": [
                "Complete API reference",
                "Getting Started / Quickstart",
                "Advanced use cases",
                "Error codes reference"
              ],
              "answerIndex": 1,
              "explanation": "Getting Started / Quickstart is most critical for new developers. It gets them from zero to a working integration fast, building confidence and momentum. If developers can't get started easily, they may give up before exploring deeper features."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "Write the Docs",
              "url": "https://www.writethedocs.org/guide/writing/beginners-guide-to-docs/"
            },
            {
              "type": "article",
              "title": "Google Developer Documentation Style Guide",
              "url": "https://developers.google.com/style"
            }
          ]
        },
        {
          "id": "lesson-code-examples",
          "slug": "code-examples-best-practices",
          "title": "Code Examples Best Practices",
          "estimated_time_minutes": 35,
          "learning_objectives": [
            "Create effective, runnable code examples",
            "Support multiple programming languages",
            "Handle edge cases in examples",
            "Maintain example quality over time"
          ],
          "prerequisites": [
            "lesson-writing-docs"
          ],
          "contentHtml": "<h2>Code Examples Best Practices</h2>\n\n<p>Code examples are the most-used part of API docs. Let's make them excellent.</p>\n\n<h3>The Perfect Code Example</h3>\n\n<p>‚úÖ Complete and Runnable:</p>\n<pre><code>// ‚úÖ Good: Everything needed to run\nconst fetch = require('node-fetch');\n\nconst API_KEY = process.env.VIDEODB_API_KEY;\n\nasync function uploadVideo() {\n  const response = await fetch('https://api.videodb.io/v1/videos', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${API_KEY}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      title: 'My Video',\n      url: 'https://example.com/video.mp4'\n    })\n  });\n  \n  const data = await response.json();\n  console.log('Video ID:', data.id);\n}\n\nuploadVideo();</code></pre>\n\n<p>‚ùå Incomplete:</p>\n<pre><code>// ‚ùå Bad: Missing imports, auth, context\nfetch('/videos', {body: {title: 'test'}})\n  .then(r => r.json())</code></pre>\n\n<h3>Multi-Language Support</h3>\n\n<p>Provide examples in popular languages:</p>\n\n<ul>\n<li><strong>cURL</strong> (universal, works anywhere)</li>\n<li><strong>JavaScript/Node.js</strong> (web developers)</li>\n<li><strong>Python</strong> (data scientists, backend)</li>\n<li><strong>Java/Go/PHP</strong> (enterprise, depending on audience)</li>\n</ul>\n\n<h3>Realistic Data</h3>\n\n<p>‚ùå Bad:</p>\n<pre><code>{\n  \"name\": \"test\",\n  \"foo\": \"bar\"\n}</code></pre>\n\n<p>‚úÖ Good:</p>\n<pre><code>{\n  \"title\": \"Product Demo Video\",\n  \"description\": \"Q4 2024 product launch demonstration\",\n  \"duration_seconds\": 180,\n  \"tags\": [\"product\", \"demo\", \"2024\"]\n}</code></pre>\n\n<h3>Error Handling</h3>\n\n<p>Show how to handle errors:</p>\n\n<pre><code>try {\n  const response = await fetch('https://api.example.com/videos', {\n    method: 'POST',\n    headers: {'Authorization': `Bearer ${API_KEY}`},\n    body: JSON.stringify(videoData)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API error: ${response.status}`);\n  }\n  \n  const data = await response.json();\n  return data;\n} catch (error) {\n  console.error('Failed to create video:', error);\n  throw error;\n}</code></pre>\n\n<h3>Maintaining Examples</h3>\n\n<ul>\n<li>‚úÖ Test examples automatically in CI/CD</li>\n<li>‚úÖ Update when API changes</li>\n<li>‚úÖ Version examples to match API versions</li>\n<li>‚úÖ Link to working sample projects/repos</li>\n</ul>\n\n<div class='callout callout-warning'>\n<strong>‚ö†Ô∏è Warning:</strong> Outdated examples are worse than no examples. They frustrate developers and damage trust.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Examples must be complete and runnable</li>\n<li>Support multiple languages (cURL, JS, Python minimum)</li>\n<li>Use realistic data, not \"foo\" and \"bar\"</li>\n<li>Show error handling</li>\n<li>Test examples automatically and keep updated</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "Why should code examples use realistic data instead of 'foo' and 'bar'?",
              "choices": [
                "It makes the code run faster",
                "It helps developers understand the context and expected data format",
                "It's required by API standards",
                "It reduces file size"
              ],
              "answerIndex": 1,
              "explanation": "Realistic data helps developers understand what kind of data the API expects and how it's structured in real-world scenarios. Generic 'foo' and 'bar' values don't provide this context, making examples less helpful."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "API Code Examples Guide",
              "url": "https://swagger.io/blog/api-documentation/api-documentation-code-examples/"
            }
          ]
        }
      ]
    },
    {
      "id": "module-advanced-concepts",
      "title": "Advanced API Concepts",
      "description": "Rate limits, pagination, webhooks, and other advanced API documentation topics.",
      "icon": "‚öôÔ∏è",
      "lessons": [
        {
          "id": "lesson-rate-limits-pagination",
          "slug": "rate-limits-pagination",
          "title": "Rate Limiting & Pagination",
          "estimated_time_minutes": 32,
          "learning_objectives": [
            "Explain rate limiting and why it exists",
            "Document rate limit headers and errors",
            "Understand pagination strategies",
            "Document pagination parameters correctly"
          ],
          "prerequisites": [
            "lesson-http-status-codes"
          ],
          "contentHtml": "<h3>Rate Limiting: Protecting the API</h3><p><strong>Rate limiting</strong> restricts how many requests a client can make in a time period. It prevents abuse and ensures fair resource allocation.</p><h3>Why Rate Limits Exist</h3><ul><li>üõ°Ô∏è Prevent API abuse and DDoS attacks</li><li>‚öñÔ∏è Ensure fair usage across all clients</li><li>üí∞ Enforce pricing tiers (free vs. paid)</li><li>üîß Protect server resources</li></ul><h3>Documenting Rate Limits</h3><p>Always document:</p><ol><li><strong>Limits:</strong> How many requests per time period (e.g., 1000 requests/hour)</li><li><strong>Headers:</strong> Response headers that show remaining quota</li><li><strong>Error response:</strong> What happens when limit is exceeded (429 status code)</li><li><strong>Reset time:</strong> When the limit resets</li></ol><h4>Example Rate Limit Headers</h4><pre><code>X-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 487\nX-RateLimit-Reset: 1640000000</code></pre><h4>429 Too Many Requests Response</h4><pre><code class='language-json'>{\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Rate limit exceeded. Try again in 42 seconds.\",\n    \"retry_after\": 42\n  }\n}</code></pre><div class='callout callout-tip'><strong>üí° Pro Tip:</strong> Clearly document different rate limits for different endpoints or tiers (free, pro, enterprise).</div><h3>Pagination: Handling Large Data Sets</h3><p><strong>Pagination</strong> breaks large result sets into smaller \"pages\" to improve performance and user experience.</p><h3>Common Pagination Strategies</h3><h4>1. Offset-Based Pagination</h4><p>Uses <code>limit</code> and <code>offset</code> parameters:</p><pre><code>GET /videos?limit=20&offset=40</code></pre><ul><li>‚úÖ Simple to implement</li><li>‚ùå Performance degrades with large offsets</li><li>‚ùå Can miss items if data changes between requests</li></ul><h4>2. Cursor-Based Pagination</h4><p>Uses a <code>cursor</code> (pointer) to the next page:</p><pre><code>GET /videos?limit=20&cursor=eyJpZCI6MTIzfQ</code></pre><ul><li>‚úÖ Consistent results even if data changes</li><li>‚úÖ Better performance</li><li>‚ùå Can't jump to arbitrary pages</li></ul><h4>3. Page-Based Pagination</h4><p>Uses <code>page</code> and <code>per_page</code> parameters:</p><pre><code>GET /videos?page=3&per_page=20</code></pre><ul><li>‚úÖ Intuitive for users</li><li>‚ùå Same issues as offset-based</li></ul><h3>Pagination Response Format</h3><p>Include metadata in responses:</p><pre><code class='language-json'>{\n  \"data\": [...],\n  \"pagination\": {\n    \"total\": 500,\n    \"page\": 3,\n    \"per_page\": 20,\n    \"total_pages\": 25,\n    \"next_cursor\": \"eyJpZCI6ODd9\",\n    \"has_more\": true\n  }\n}</code></pre><div class='callout callout-warning'><strong>‚ö†Ô∏è Common Pitfall:</strong> Don't forget to document the maximum allowed page size (e.g., \"max 100 items per page\").</div><div class='callout callout-recap'><strong>üß† Quick Recap:</strong><ul><li>Rate limits protect the API from abuse</li><li>Document: limits, headers, error response, reset time</li><li>Pagination strategies: offset, cursor, page-based</li><li>Include pagination metadata in responses</li></ul></div>",
          "examples": [
            {
              "title": "Rate Limit Documentation Example",
              "language": "markdown",
              "code": "## Rate Limits\n\nThe VideoDB API enforces rate limits to ensure fair usage:\n\n- **Free tier:** 100 requests/hour\n- **Pro tier:** 1,000 requests/hour\n- **Enterprise:** Custom limits\n\n### Rate Limit Headers\n\nEvery response includes these headers:\n\n```\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 487\nX-RateLimit-Reset: 1640000000\n```\n\n### When You Hit the Limit\n\nStatus: `429 Too Many Requests`\n\n```json\n{\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Rate limit exceeded\",\n    \"retry_after\": 120\n  }\n}\n```"
            },
            {
              "title": "Cursor-Based Pagination Example",
              "language": "bash",
              "code": "# First request\ncurl 'https://api.videodb.io/v1/videos?limit=20'\n\n# Response includes next_cursor\n{\n  \"data\": [...],\n  \"next_cursor\": \"eyJpZCI6MjB9\"\n}\n\n# Next request uses the cursor\ncurl 'https://api.videodb.io/v1/videos?limit=20&cursor=eyJpZCI6MjB9'"
            }
          ],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What HTTP status code indicates rate limit exceeded?",
              "choices": [
                "400",
                "403",
                "429",
                "500"
              ],
              "answerIndex": 2,
              "explanation": "429 Too Many Requests is the standard status code for rate limit errors."
            },
            {
              "id": "q2",
              "type": "mcq",
              "question": "Which pagination method is best for consistent results when data changes frequently?",
              "choices": [
                "Offset-based",
                "Cursor-based",
                "Page-based",
                "All are equal"
              ],
              "answerIndex": 1,
              "explanation": "Cursor-based pagination provides consistent results even when the underlying data changes between requests."
            },
            {
              "id": "q3",
              "type": "mcq",
              "question": "Based on this lesson about 'Rate Limiting & Pagination', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q4",
              "type": "mcq",
              "question": "Based on this lesson about 'Rate Limiting & Pagination', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            },
            {
              "id": "q5",
              "type": "mcq",
              "question": "Based on this lesson about 'Rate Limiting & Pagination', which statement is most accurate?",
              "choices": [
                "This concept applies only to specific API types",
                "This is a foundational principle used across all modern APIs",
                "This is only relevant for enterprise applications",
                "This concept is becoming obsolete in modern development"
              ],
              "answerIndex": 1,
              "explanation": "This is a fundamental concept that applies broadly across API development and documentation. Understanding these core principles is essential for success as an API documentation writer, regardless of the specific API type or industry you're working in."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "API Rate Limiting Best Practices",
              "url": "https://cloud.google.com/architecture/rate-limiting-strategies-techniques"
            }
          ]
        },
        {
          "id": "lesson-webhooks",
          "slug": "webhooks-and-events",
          "title": "Webhooks & Event-Driven APIs",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Understand webhooks vs polling",
            "Implement webhook endpoints",
            "Handle webhook security",
            "Document webhook events clearly"
          ],
          "prerequisites": [
            "lesson-rate-limiting"
          ],
          "contentHtml": "<h2>Webhooks & Event-Driven APIs</h2>\n\n<p>Webhooks push data to clients when events occur, eliminating constant polling.</p>\n\n<h3>Polling vs Webhooks</h3>\n\n<p><strong>Polling (‚ùå Inefficient):</strong></p>\n<pre><code># Client repeatedly checks for updates\nGET /api/orders/123/status  # Every 30 seconds...\nGET /api/orders/123/status\nGET /api/orders/123/status</code></pre>\n\n<p><strong>Webhooks (‚úÖ Efficient):</strong></p>\n<pre><code># Server notifies client when status changes\nPOST https://your-app.com/webhooks/order-status\n{\n  \"event\": \"order.completed\",\n  \"order_id\": 123,\n  \"status\": \"shipped\"\n}</code></pre>\n\n<h3>How Webhooks Work</h3>\n\n<ol>\n<li>Client registers webhook URL with API</li>\n<li>Event occurs on server (order completed, payment processed, etc.)</li>\n<li>Server sends HTTP POST to client's webhook URL</li>\n<li>Client processes event and returns 200 OK</li>\n</ol>\n\n<h3>Webhook Security</h3>\n\n<p>Verify webhooks are authentic:</p>\n\n<pre><code># Signature in header\nX-Webhook-Signature: sha256=abc123...\n\n# Client validates using shared secret\ncomputed_signature = HMAC_SHA256(secret, payload)\nif computed_signature == received_signature:\n    process_webhook()\nelse:\n    reject()</code></pre>\n\n<h3>Documenting Webhooks</h3>\n\n<p>Document:</p>\n<ul>\n<li>All event types (<code>user.created</code>, <code>payment.succeeded</code>, etc.)</li>\n<li>Payload structure for each event</li>\n<li>How to verify signatures</li>\n<li>Retry behavior (what if webhook fails?)</li>\n<li>Timeout expectations</li>\n</ul>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Webhooks push events to clients (vs polling)</li>\n<li>Client provides URL, server POSTs events</li>\n<li>Always verify webhook signatures for security</li>\n<li>Document all event types and payloads</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What's the main advantage of webhooks over polling?",
              "choices": [
                "Webhooks are easier to implement",
                "Webhooks push data immediately when events occur, reducing load and latency",
                "Webhooks don't require authentication",
                "Webhooks are more secure"
              ],
              "answerIndex": 1,
              "explanation": "Webhooks push data immediately when events occur, eliminating the need for constant polling. This reduces server load, network traffic, and latency in receiving updates."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "Webhooks Guide",
              "url": "https://stripe.com/docs/webhooks"
            }
          ]
        },
        {
          "id": "lesson-caching",
          "slug": "caching-strategies",
          "title": "Caching Strategies & HTTP Caching",
          "estimated_time_minutes": 40,
          "learning_objectives": [
            "Understand HTTP caching headers",
            "Implement cache-control strategies",
            "Use ETags for conditional requests",
            "Document caching behavior"
          ],
          "prerequisites": [
            "lesson-http-methods-deep"
          ],
          "contentHtml": "<h2>Caching Strategies & HTTP Caching</h2>\n\n<p>Caching dramatically improves performance. Let's use it effectively.</p>\n\n<h3>Why Cache?</h3>\n\n<ul>\n<li>‚úÖ Reduces server load</li>\n<li>‚úÖ Faster response times</li>\n<li>‚úÖ Lower bandwidth costs</li>\n<li>‚úÖ Better user experience</li>\n</ul>\n\n<h3>Cache-Control Header</h3>\n\n<pre><code>Cache-Control: public, max-age=3600\n\n# Directives:\npublic           # Anyone can cache\nprivate          # Only user's browser can cache\nno-cache         # Revalidate before using cache\nno-store         # Never cache (sensitive data)\nmax-age=3600     # Cache for 3600 seconds (1 hour)\nmust-revalidate  # Must check if still valid after expiration</code></pre>\n\n<h3>ETags (Conditional Requests)</h3>\n\n<p>ETags detect if content changed:</p>\n\n<pre><code># Initial request\nGET /api/users/123\n\nResponse:\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n{...user data...}\n\n# Subsequent request (check if changed)\nGET /api/users/123\nIf-None-Match: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n\nResponse (if unchanged):\n304 Not Modified\n(no body, use cached version)\n\nResponse (if changed):\n200 OK\nETag: \"new-etag-value\"\n{...updated user data...}</code></pre>\n\n<h3>Caching Strategies</h3>\n\n<ul>\n<li><strong>Static data:</strong> <code>Cache-Control: public, max-age=31536000</code> (1 year)</li>\n<li><strong>User data:</strong> <code>Cache-Control: private, max-age=300</code> (5 min)</li>\n<li><strong>Sensitive data:</strong> <code>Cache-Control: no-store</code></li>\n<li><strong>Frequently changing:</strong> Use ETags with <code>no-cache</code></li>\n</ul>\n\n<div class='callout callout-warning'>\n<strong>‚ö†Ô∏è Never cache:</strong> Sensitive data (PII, auth tokens, financial info). Use <code>Cache-Control: no-store</code>.\n</div>\n\n<div class='callout callout-recap'>\n<strong>üß† Quick Recap:</strong>\n<ul>\n<li>Cache-Control header defines caching behavior</li>\n<li>ETags enable conditional requests (304 Not Modified)</li>\n<li>Cache static data aggressively, user data moderately</li>\n<li>Never cache sensitive information</li>\n<li>Document caching behavior for each endpoint</li>\n</ul>\n</div>\n",
          "examples": [],
          "quiz": [
            {
              "id": "q1",
              "type": "mcq",
              "question": "What does a 304 Not Modified response mean?",
              "choices": [
                "The resource has been deleted",
                "The resource hasn't changed, use cached version",
                "The request was invalid",
                "The server is overloaded"
              ],
              "answerIndex": 1,
              "explanation": "304 Not Modified means the resource hasn't changed since the client last fetched it (based on ETag or Last-Modified). The client should use its cached version, saving bandwidth and processing time."
            }
          ],
          "resources": [
            {
              "type": "article",
              "title": "HTTP Caching",
              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching"
            }
          ]
        }
      ]
    }
  ]
};

export default courseData;
